<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Ant</title><link href="http://www.zhangge208.com/" rel="alternate"></link><link href="http://www.zhangge208.com/feeds/algorithm.atom.xml" rel="self"></link><id>http://www.zhangge208.com/</id><updated>2015-09-09T00:00:00+08:00</updated><entry><title>Minimum Size Subarray Sum</title><link href="http://www.zhangge208.com/pages/2015/09/09/minimum-size-subarray-sum.html" rel="alternate"></link><updated>2015-09-09T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-09-09:pages/2015/09/09/minimum-size-subarray-sum.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Minimum Size Subarray Sum&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Given an array of &lt;strong&gt;n&lt;/strong&gt; positive integers and a positive integer &lt;strong&gt;s&lt;/strong&gt;, find the minimal length of a subarray of which the sum ≥ &lt;strong&gt;s&lt;/strong&gt;. If there isn't one, return 0 instead.&lt;/p&gt;
&lt;p&gt;For example, given the array &lt;code&gt;[2,3,1,2,4,3]&lt;/code&gt; and &lt;code&gt;s = 7&lt;/code&gt;,
the subarray &lt;code&gt;[4,3]&lt;/code&gt; has the minimal length under the problem  constraint.&lt;/p&gt;
&lt;p&gt;click to show more practice.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;More practice:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(nlogn).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Credits:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Special thanks to @Freezen for adding this problem and creating all test cases.&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public int minSubArrayLen(int s, int[] nums) {
        if (nums.length == 0 || nums == null) {
            return 0;
        }
        int[] sum = new int[nums.length];
        sum[0] = nums[0];
        for (int i = 1; i &amp;lt; nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i];
        }
        int ans = Integer.MAX_VALUE;
        int start, end, mid;
        for (int i = 0; i &amp;lt; sum.length; i++) {
            start = i;
            end = sum.length - 1;
            while (start + 1 &amp;lt; end) {
                mid = start + (end - start) / 2;
                if (sum[mid] - sum[i] + nums[i] == s){
                    end = mid;
                    break;
                }
                else if (sum[mid] - sum[i] + nums[i] &amp;lt; s) {
                    start = mid;
                }
                else {
                    end = mid;
                }
            }
            if (sum[start] - sum[i] + nums[i] &amp;gt;= s){
                ans = Math.min(ans, start - i + 1);
            }
            if (sum[end] - sum[i] + nums[i] &amp;gt;= s){
                ans = Math.min(ans, end - i + 1);
            }

        }
        return (ans == Integer.MAX_VALUE ? 0 : ans);
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;思路&lt;/h2&gt;
&lt;h3&gt;O(n) solution&lt;/h3&gt;
&lt;h3&gt;O(nlogn) solution&lt;/h3&gt;
&lt;p&gt;O(nlogn)的解法很不易想到，tag上提示为二分搜索，binary search的复杂度为O(logn)，那么在外层应该有一个for循环。&lt;/p&gt;</summary><category term="Algorithm Binary Search"></category></entry><entry><title>Leetcode@Convert Sorted List to Binary Search Tree</title><link href="http://www.zhangge208.com/pages/2015/06/30/leetcodeconvert-sorted-list-to-binary-search-tree.html" rel="alternate"></link><updated>2015-06-30T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-06-30:pages/2015/06/30/leetcodeconvert-sorted-list-to-binary-search-tree.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Convert Sorted List to Binary Search Tree&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;与&lt;a href="http://www.zhangge208.com/pages/2015/06/29/leetcodeconvert-sorted-array-to-binary-search-tree.html"&gt;Convert Sorted Array to Binary Search Tree&lt;/a&gt;的思路很像，首先是得找到根节点，但考虑到是链表，没法直接到中间的元素，只能依次移动指针，联想到中序遍历与BST的关系，我们依据inorder来构造BST，前半部分为左子树，然后根节点，后半部分为右子树。&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * Definition for singly-linked list.&lt;/span&gt;
&lt;span class="cm"&gt; * public class ListNode {&lt;/span&gt;
&lt;span class="cm"&gt; *     int val;&lt;/span&gt;
&lt;span class="cm"&gt; *     ListNode next;&lt;/span&gt;
&lt;span class="cm"&gt; *     ListNode(int x) { val = x; }&lt;/span&gt;
&lt;span class="cm"&gt; * }&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * Definition for a binary tree node.&lt;/span&gt;
&lt;span class="cm"&gt; * public class TreeNode {&lt;/span&gt;
&lt;span class="cm"&gt; *     int val;&lt;/span&gt;
&lt;span class="cm"&gt; *     TreeNode left;&lt;/span&gt;
&lt;span class="cm"&gt; *     TreeNode right;&lt;/span&gt;
&lt;span class="cm"&gt; *     TreeNode(int x) { val = x; }&lt;/span&gt;
&lt;span class="cm"&gt; * }&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
public&lt;span class="w"&gt; &lt;/span&gt;class&lt;span class="w"&gt; &lt;/span&gt;Solution&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;private&lt;span class="w"&gt; &lt;/span&gt;ListNode&lt;span class="w"&gt; &lt;/span&gt;current&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;public&lt;span class="w"&gt; &lt;/span&gt;TreeNode&lt;span class="w"&gt; &lt;/span&gt;sortedListToBST&lt;span class="o"&gt;(&lt;/span&gt;ListNode&lt;span class="w"&gt; &lt;/span&gt;head&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;int&lt;span class="w"&gt; &lt;/span&gt;size&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;getLength&lt;span class="o"&gt;(&lt;/span&gt;head&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;current&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;head&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;sortedListToBSTHelper&lt;span class="o"&gt;(&lt;/span&gt;size&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;private&lt;span class="w"&gt; &lt;/span&gt;int&lt;span class="w"&gt; &lt;/span&gt;getLength&lt;span class="o"&gt;(&lt;/span&gt;ListNode&lt;span class="w"&gt; &lt;/span&gt;head&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;int&lt;span class="w"&gt; &lt;/span&gt;length&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;while&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;head&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;null&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;length&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;head&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;head&lt;span class="o"&gt;.&lt;/span&gt;next&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;length&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;public&lt;span class="w"&gt; &lt;/span&gt;TreeNode&lt;span class="w"&gt; &lt;/span&gt;sortedListToBSTHelper&lt;span class="o"&gt;(&lt;/span&gt;int&lt;span class="w"&gt; &lt;/span&gt;size&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;size&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;null&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;TreeNode&lt;span class="w"&gt; &lt;/span&gt;left&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;sortedListToBSTHelper&lt;span class="o"&gt;(&lt;/span&gt;size&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;TreeNode&lt;span class="w"&gt; &lt;/span&gt;root&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;new&lt;span class="w"&gt; &lt;/span&gt;TreeNode&lt;span class="o"&gt;(&lt;/span&gt;current&lt;span class="o"&gt;.&lt;/span&gt;val&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;current&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;current&lt;span class="o"&gt;.&lt;/span&gt;next&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;TreeNode&lt;span class="w"&gt; &lt;/span&gt;right&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;sortedListToBSTHelper&lt;span class="o"&gt;(&lt;/span&gt;size&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;size&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;root&lt;span class="o"&gt;.&lt;/span&gt;left&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;left&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;root&lt;span class="o"&gt;.&lt;/span&gt;right&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;right&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;root&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Leetcode Binary Tree"></category></entry><entry><title>Leetcode@Convert Sorted Array to Binary Search Tree</title><link href="http://www.zhangge208.com/pages/2015/06/29/leetcodeconvert-sorted-array-to-binary-search-tree.html" rel="alternate"></link><updated>2015-06-29T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-06-29:pages/2015/06/29/leetcodeconvert-sorted-array-to-binary-search-tree.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Convert Sorted Array to Binary Search Tree&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Given an array where elements are sorted in ascending order, convert it to a height balanced BST.&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;按照题目要求，第一想法是得到树的根节点，如果没有构建平衡二叉搜索树的要求，那很容易，联想BST和binary search的关系，选择排序数组中间元素作为根节点，元素左边的全部元素作为左子树，右边全部元素作为右子树，然后用同样的方法寻找根节点，递归。&lt;/p&gt;
&lt;p&gt;需要注意对边界的处理，必须满足BST的定义。&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * Definition for a binary tree node.&lt;/span&gt;
&lt;span class="cm"&gt; * public class TreeNode {&lt;/span&gt;
&lt;span class="cm"&gt; *     int val;&lt;/span&gt;
&lt;span class="cm"&gt; *     TreeNode left;&lt;/span&gt;
&lt;span class="cm"&gt; *     TreeNode right;&lt;/span&gt;
&lt;span class="cm"&gt; *     TreeNode(int x) { val = x; }&lt;/span&gt;
&lt;span class="cm"&gt; * }&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
public&lt;span class="w"&gt; &lt;/span&gt;class&lt;span class="w"&gt; &lt;/span&gt;Solution&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;public&lt;span class="w"&gt; &lt;/span&gt;TreeNode&lt;span class="w"&gt; &lt;/span&gt;sortedArrayToBST&lt;span class="o"&gt;(&lt;/span&gt;int&lt;span class="err"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;nums&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;nums&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;null&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;null&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;buildTree&lt;span class="o"&gt;(&lt;/span&gt;nums&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;nums&lt;span class="o"&gt;.&lt;/span&gt;length&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;private&lt;span class="w"&gt; &lt;/span&gt;TreeNode&lt;span class="w"&gt; &lt;/span&gt;buildTree&lt;span class="o"&gt;(&lt;/span&gt;int&lt;span class="err"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;nums&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;int&lt;span class="w"&gt; &lt;/span&gt;start&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;int&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;end&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;start&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;end&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;null&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;TreeNode&lt;span class="w"&gt; &lt;/span&gt;node&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;new&lt;span class="w"&gt; &lt;/span&gt;TreeNode&lt;span class="o"&gt;(&lt;/span&gt;nums&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;end&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;start&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;node&lt;span class="o"&gt;.&lt;/span&gt;left&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;buildTree&lt;span class="o"&gt;(&lt;/span&gt;nums&lt;span class="o"&gt;,&lt;/span&gt;start&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;end&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;start&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;node&lt;span class="o"&gt;.&lt;/span&gt;right&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;buildTree&lt;span class="o"&gt;(&lt;/span&gt;nums&lt;span class="o"&gt;,(&lt;/span&gt;&lt;span class="kr"&gt;end&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;start&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;end&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;node&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Leetcode Binary Tree"></category></entry><entry><title>Leetcode@Leetcode@Invert Binary Tree</title><link href="http://www.zhangge208.com/pages/2015/06/13/leetcodeleetcodeinvert-binary-tree.html" rel="alternate"></link><updated>2015-06-13T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-06-13:pages/2015/06/13/leetcodeleetcodeinvert-binary-tree.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Leetcode@Invert Binary Tree&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Invert a binary tree.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;     4
   /   \
  2     7
 / \   / \
1   3 6   9
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;to&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;     4
   /   \
  7     2
 / \   / \
9   6 3   1
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;非递归的还没想出来，不会做，那就来递归的吧先，递归很简单，交换左右节点就跟交换a,b两个数一样，需要一个中间变量，先把左子树的指针赋给中间变量，然后交换。&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * Definition for a binary tree node.&lt;/span&gt;
&lt;span class="cm"&gt; * public class TreeNode {&lt;/span&gt;
&lt;span class="cm"&gt; *     int val;&lt;/span&gt;
&lt;span class="cm"&gt; *     TreeNode left;&lt;/span&gt;
&lt;span class="cm"&gt; *     TreeNode right;&lt;/span&gt;
&lt;span class="cm"&gt; *     TreeNode(int x) { val = x; }&lt;/span&gt;
&lt;span class="cm"&gt; * }&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
public&lt;span class="w"&gt; &lt;/span&gt;class&lt;span class="w"&gt; &lt;/span&gt;Solution&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;public&lt;span class="w"&gt; &lt;/span&gt;TreeNode&lt;span class="w"&gt; &lt;/span&gt;invertTree&lt;span class="o"&gt;(&lt;/span&gt;TreeNode&lt;span class="w"&gt; &lt;/span&gt;root&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;root&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;null&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;root&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;TreeNode&lt;span class="w"&gt; &lt;/span&gt;temp&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;root&lt;span class="o"&gt;.&lt;/span&gt;left&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;root&lt;span class="o"&gt;.&lt;/span&gt;left&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;root&lt;span class="o"&gt;.&lt;/span&gt;right&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;root&lt;span class="o"&gt;.&lt;/span&gt;right&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;temp&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;invertTree&lt;span class="o"&gt;(&lt;/span&gt;root&lt;span class="o"&gt;.&lt;/span&gt;left&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;invertTree&lt;span class="o"&gt;(&lt;/span&gt;root&lt;span class="o"&gt;.&lt;/span&gt;right&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;root&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Leetcode Binary Tree"></category></entry><entry><title>Leetcode@Validate Binary Search Tree</title><link href="http://www.zhangge208.com/pages/2015/06/13/leetcodevalidate-binary-search-tree.html" rel="alternate"></link><updated>2015-06-13T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-06-13:pages/2015/06/13/leetcodevalidate-binary-search-tree.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Leetcode@Validate Binary Search Tree&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Given a binary tree, determine if it is a valid binary search tree (BST).&lt;/p&gt;
&lt;p&gt;Assume a BST is defined as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The left subtree of a node contains only nodes with keys less - than the node's key.&lt;/li&gt;
&lt;li&gt;The right subtree of a node contains only nodes with keys greater than the node's key.&lt;/li&gt;
&lt;li&gt;Both the left and right subtrees must also be binary search trees.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;1.递归：设置上下限(&lt;a href="http://blog.csdn.net/fightforyourdream/article/details/14444883"&gt;http://blog.csdn.net/fightforyourdream/article/details/14444883&lt;/a&gt;)，在递归左右子树时为它们设置最大值、最小值，如果节点值超过限定，肯定不是，然后下一次递归时将上下限继续传递下去&lt;/p&gt;
&lt;p&gt;2.递归：分治法递归求解&lt;/p&gt;
&lt;p&gt;3.非递归：栈实现，对树进行中序遍历，然后看是否从左到右有序&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * Definition for a binary tree node.&lt;/span&gt;
&lt;span class="cm"&gt; * public class TreeNode {&lt;/span&gt;
&lt;span class="cm"&gt; *     int val;&lt;/span&gt;
&lt;span class="cm"&gt; *     TreeNode left;&lt;/span&gt;
&lt;span class="cm"&gt; *     TreeNode right;&lt;/span&gt;
&lt;span class="cm"&gt; *     TreeNode(int x) { val = x; }&lt;/span&gt;
&lt;span class="cm"&gt; * }&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
public&lt;span class="w"&gt; &lt;/span&gt;class&lt;span class="w"&gt; &lt;/span&gt;Solution&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;public&lt;span class="w"&gt; &lt;/span&gt;boolean&lt;span class="w"&gt; &lt;/span&gt;isValidBST&lt;span class="o"&gt;(&lt;/span&gt;TreeNode&lt;span class="w"&gt; &lt;/span&gt;root&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;isValidBST&lt;span class="o"&gt;(&lt;/span&gt;root&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;Long&lt;span class="o"&gt;.&lt;/span&gt;MIN_VALUE&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;Long&lt;span class="o"&gt;.&lt;/span&gt;MAX_VALUE&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;private&lt;span class="w"&gt; &lt;/span&gt;boolean&lt;span class="w"&gt; &lt;/span&gt;isValidBST&lt;span class="o"&gt;(&lt;/span&gt;TreeNode&lt;span class="w"&gt; &lt;/span&gt;root&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;long&lt;span class="w"&gt; &lt;/span&gt;min&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;long&lt;span class="w"&gt; &lt;/span&gt;max&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;root&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;null&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;true&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;root&lt;span class="o"&gt;.&lt;/span&gt;val&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;min&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;||&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;root&lt;span class="o"&gt;.&lt;/span&gt;val&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;max&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;false&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;isValidBST&lt;span class="o"&gt;(&lt;/span&gt;root&lt;span class="o"&gt;.&lt;/span&gt;left&lt;span class="o"&gt;,&lt;/span&gt;min&lt;span class="o"&gt;,&lt;/span&gt;root&lt;span class="o"&gt;.&lt;/span&gt;val&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;isValidBST&lt;span class="o"&gt;(&lt;/span&gt;root&lt;span class="o"&gt;.&lt;/span&gt;right&lt;span class="o"&gt;,&lt;/span&gt;root&lt;span class="o"&gt;.&lt;/span&gt;val&lt;span class="o"&gt;,&lt;/span&gt;max&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Leetcode Binary Tree"></category></entry><entry><title>Leetcode@Leetcode@Rotate List</title><link href="http://www.zhangge208.com/pages/2015/06/02/leetcodeleetcoderotate-list.html" rel="alternate"></link><updated>2015-06-02T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-06-02:pages/2015/06/02/leetcodeleetcoderotate-list.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Leetcode@Rotate List&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Given a list, rotate the list to the right by k places, where k is non-negative.&lt;/p&gt;
&lt;p&gt;For example:
Given &lt;code&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL&lt;/code&gt; and k = &lt;code&gt;2&lt;/code&gt;,
return &lt;code&gt;4-&amp;gt;5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;NULL&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;把问题分割，题目要求部分翻转，那么首先要得到开始翻转的位置
这与Remove Nth Node From End of List的思路一致，运用快慢指针，得到要翻转的位置，这部分问题解决。然后就是链表的连接，由于翻转后并不知道头节点是谁，所以需要dummy node来解决这一问题。然后画个图，搞清每一步的连接。链表连接的问题还是要多画图分析。
题目中有个小陷阱，就是翻转位置标识k，并没有说明k有多大，所以需要进行取余操作，那么就先需要知道链表的长度，链表长度的得到是很简单的，遍历一遍，拿一个计数器记录就好。
关于边界的考虑，一定要记得异常处理，首先是链表判空；然后在进行快慢指针的过程时，要保证fast-&amp;gt;next不为空；在获取链表长度时也需要让链表head！= NULL。&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Solution&lt;/span&gt; {
&lt;span class="n"&gt;public:&lt;/span&gt;
    &lt;span class="n"&gt;ListNode&lt;/span&gt; *&lt;span class="n"&gt;rotateRight&lt;/span&gt;(&lt;span class="n"&gt;ListNode&lt;/span&gt; *&lt;span class="n"&gt;head&lt;/span&gt;, &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;) {
        &lt;span class="k"&gt;if&lt;/span&gt;(&lt;span class="n"&gt;head&lt;/span&gt; == &lt;span class="n"&gt;NULL&lt;/span&gt; )
        {
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;;
        }

        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt; = &lt;span class="n"&gt;getlength&lt;/span&gt;(&lt;span class="n"&gt;head&lt;/span&gt;);
        &lt;span class="n"&gt;k&lt;/span&gt; = &lt;span class="n"&gt;k&lt;/span&gt; % &lt;span class="n"&gt;length&lt;/span&gt;;

        &lt;span class="n"&gt;ListNode&lt;/span&gt; *&lt;span class="n"&gt;dummy&lt;/span&gt; = &lt;span class="nb"&gt;new&lt;/span&gt; &lt;span class="n"&gt;ListNode&lt;/span&gt;(-&lt;span class="mi"&gt;1&lt;/span&gt;);
        &lt;span class="n"&gt;dummy-&lt;/span&gt;&amp;gt;&lt;span class="k"&gt;next&lt;/span&gt; = &lt;span class="n"&gt;head&lt;/span&gt;;
        &lt;span class="n"&gt;head&lt;/span&gt; = &lt;span class="n"&gt;dummy&lt;/span&gt;;

        &lt;span class="n"&gt;ListNode&lt;/span&gt; *&lt;span class="n"&gt;fast&lt;/span&gt; = &lt;span class="n"&gt;dummy&lt;/span&gt;;
        &lt;span class="n"&gt;ListNode&lt;/span&gt; *&lt;span class="n"&gt;slow&lt;/span&gt; = &lt;span class="n"&gt;dummy&lt;/span&gt;;

        &lt;span class="k"&gt;for&lt;/span&gt;(&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; = &lt;span class="mi"&gt;0&lt;/span&gt;; &lt;span class="n"&gt;i&lt;/span&gt; &amp;lt; &lt;span class="n"&gt;k&lt;/span&gt;; &lt;span class="n"&gt;i&lt;/span&gt;++)
        {
            &lt;span class="n"&gt;fast&lt;/span&gt; = &lt;span class="n"&gt;fast-&lt;/span&gt;&amp;gt;&lt;span class="k"&gt;next&lt;/span&gt;;
        }

        &lt;span class="k"&gt;while&lt;/span&gt;(&lt;span class="n"&gt;fast-&lt;/span&gt;&amp;gt;&lt;span class="k"&gt;next&lt;/span&gt; != &lt;span class="n"&gt;NULL&lt;/span&gt;)
        {
            &lt;span class="n"&gt;fast&lt;/span&gt; = &lt;span class="n"&gt;fast-&lt;/span&gt;&amp;gt;&lt;span class="k"&gt;next&lt;/span&gt;;
            &lt;span class="n"&gt;slow&lt;/span&gt; = &lt;span class="n"&gt;slow-&lt;/span&gt;&amp;gt;&lt;span class="k"&gt;next&lt;/span&gt;;
        }

        &lt;span class="n"&gt;fast-&lt;/span&gt;&amp;gt;&lt;span class="k"&gt;next&lt;/span&gt; = &lt;span class="n"&gt;dummy-&lt;/span&gt;&amp;gt;&lt;span class="k"&gt;next&lt;/span&gt;;
        &lt;span class="n"&gt;dummy-&lt;/span&gt;&amp;gt;&lt;span class="k"&gt;next&lt;/span&gt; = &lt;span class="n"&gt;slow-&lt;/span&gt;&amp;gt;&lt;span class="k"&gt;next&lt;/span&gt;;
        &lt;span class="n"&gt;slow-&lt;/span&gt;&amp;gt;&lt;span class="k"&gt;next&lt;/span&gt; = &lt;span class="n"&gt;NULL&lt;/span&gt;;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;dummy-&lt;/span&gt;&amp;gt;&lt;span class="k"&gt;next&lt;/span&gt;;
    }
&lt;span class="n"&gt;private:&lt;/span&gt;
    &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;getlength&lt;/span&gt;(&lt;span class="n"&gt;ListNode&lt;/span&gt; *&lt;span class="n"&gt;head&lt;/span&gt;)
    {
        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt; = &lt;span class="mi"&gt;0&lt;/span&gt;;

        &lt;span class="k"&gt;while&lt;/span&gt;(&lt;span class="n"&gt;head&lt;/span&gt; != &lt;span class="n"&gt;NULL&lt;/span&gt;)
        {
            &lt;span class="n"&gt;length&lt;/span&gt;++;
            &lt;span class="n"&gt;head&lt;/span&gt; = &lt;span class="n"&gt;head-&lt;/span&gt;&amp;gt;&lt;span class="k"&gt;next&lt;/span&gt;;
        }
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;;
    }
};
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Leetcode Linked List"></category></entry><entry><title>Leetcode@Remove Linked List Elements</title><link href="http://www.zhangge208.com/pages/2015/06/02/leetcoderemove-linked-list-elements.html" rel="alternate"></link><updated>2015-06-02T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-06-02:pages/2015/06/02/leetcoderemove-linked-list-elements.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Leetcode@Remove Linked List Elements&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Remove all elements from a linked list of integers that have value val.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Given:&lt;/em&gt;&lt;/strong&gt; 1 --&amp;gt; 2 --&amp;gt; 6 --&amp;gt; 3 --&amp;gt; 4 --&amp;gt; 5 --&amp;gt; 6, val = 6&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Return:&lt;/em&gt;&lt;/strong&gt; 1 --&amp;gt; 2 --&amp;gt; 3 --&amp;gt; 4 --&amp;gt; 5&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;基础的链表操作题目。首先考虑到头节点可能会被修改，所以要使用dummynode，然后根据判断条件进行remove即可，现指针节点为p，p的后继节点的值若与给定的val相等，则令p指向p后继的后继即可移除p现在的后继。注意边界条件的处理。&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * Definition for singly-linked list.&lt;/span&gt;
&lt;span class="cm"&gt; * public class ListNode {&lt;/span&gt;
&lt;span class="cm"&gt; *     int val;&lt;/span&gt;
&lt;span class="cm"&gt; *     ListNode next;&lt;/span&gt;
&lt;span class="cm"&gt; *     ListNode(int x) { val = x; }&lt;/span&gt;
&lt;span class="cm"&gt; * }&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
public&lt;span class="w"&gt; &lt;/span&gt;class&lt;span class="w"&gt; &lt;/span&gt;Solution&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;public&lt;span class="w"&gt; &lt;/span&gt;ListNode&lt;span class="w"&gt; &lt;/span&gt;removeElements&lt;span class="o"&gt;(&lt;/span&gt;ListNode&lt;span class="w"&gt; &lt;/span&gt;head&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;int&lt;span class="w"&gt; &lt;/span&gt;val&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;head&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;null&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;null&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;ListNode&lt;span class="w"&gt; &lt;/span&gt;dummy&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;new&lt;span class="w"&gt; &lt;/span&gt;ListNode&lt;span class="o"&gt;(-&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;dummy&lt;span class="o"&gt;.&lt;/span&gt;next&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;head&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;head&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;dummy&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;while&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;head&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;null&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;head&lt;span class="o"&gt;.&lt;/span&gt;next&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;null&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;head&lt;span class="o"&gt;.&lt;/span&gt;next&lt;span class="o"&gt;.&lt;/span&gt;val&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;val&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;head&lt;span class="o"&gt;.&lt;/span&gt;next&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;head&lt;span class="o"&gt;.&lt;/span&gt;next&lt;span class="o"&gt;.&lt;/span&gt;next&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kr"&gt;else&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;head&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;head&lt;span class="o"&gt;.&lt;/span&gt;next&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;dummy&lt;span class="o"&gt;.&lt;/span&gt;next&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Leetcode Linked List"></category></entry><entry><title>Leetcode@Kth Largest Element in an Array</title><link href="http://www.zhangge208.com/pages/2015/05/28/leetcodekth-largest-element-in-an-array.html" rel="alternate"></link><updated>2015-05-28T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-05-28:pages/2015/05/28/leetcodekth-largest-element-in-an-array.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Leetcode@Kth Largest Element in an Array&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.&lt;/p&gt;
&lt;p&gt;For example,
Given [3,2,1,5,6,4] and k = 2, return 5.&lt;/p&gt;
&lt;p&gt;Note: 
You may assume k is always valid, 1 ≤ k ≤ array's length.&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;使用优先队列来解决。由于题目是求第k大的数，反过来也就是求第n-k+1小的数，那么只需要生成一个队长为k的优先队列，把n个数中k个最大的数放入队列中即可，此时返回队头即可。所以，对于nums中前k个数，我们全部放入优先队列中；对于剩下的n-k个元素，我们挨个将其与现有队头比较，如果比现有队头大，那么更新队头，原队头出队，元素入队。&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public int findKthLargest(int[] nums, int k) {
        PriorityQueue&amp;lt;Integer&amp;gt; queue = new PriorityQueue&amp;lt;Integer&amp;gt;(k);
        for (int i = 0; i &amp;lt; nums.length; i++){
            if (queue.size() &amp;lt; k){
                queue.add(nums[i]);
            }
            else{
                if (nums[i] &amp;gt; queue.peek()){
                    queue.remove();
                    queue.add(nums[i]);
                }
            }
        }
        return queue.remove();
    }
}
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Leetcode Heap"></category></entry><entry><title>Leetcode@Best Time to Buy and Sell Stock I</title><link href="http://www.zhangge208.com/pages/2015/05/26/leetcodebest-time-to-buy-and-sell-stock-i.html" rel="alternate"></link><updated>2015-05-26T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-05-26:pages/2015/05/26/leetcodebest-time-to-buy-and-sell-stock-i.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Leetcode@Best Time to Buy and Sell Stock I&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;/p&gt;
&lt;p&gt;If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;动态规划的想法，属于sequence DP&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;state：f[i]代表前i天的最大收益&lt;/li&gt;
&lt;li&gt;function：f[i] = max(f[i-1],f[i-1]+prices[i]-prices[i-1])&lt;/li&gt;
&lt;li&gt;intialize:f[0] = 0&lt;/li&gt;
&lt;li&gt;answer:f[n] &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;代码&lt;/h2&gt;</summary><category term="Algorithm Leetcode Dynamic Programming"></category></entry><entry><title>Leetcode@Best Time to Buy and Sell Stock II</title><link href="http://www.zhangge208.com/pages/2015/05/26/leetcodebest-time-to-buy-and-sell-stock-ii.html" rel="alternate"></link><updated>2015-05-26T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-05-26:pages/2015/05/26/leetcodebest-time-to-buy-and-sell-stock-ii.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Leetcode@Best Time to Buy and Sell Stock II&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;/p&gt;
&lt;p&gt;Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;贪心的想法，既然能交易多次，那就把所有赚钱的时间段赚取的利益相加。首先要构造一个差值数组（前缀和数组？），即price_diff[i] = prices[i] - prices[i-1],然后把全部price_diff &amp;gt; 0的部分相加，即为最大利益&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Solution&lt;/span&gt; {
&lt;span class="n"&gt;public:&lt;/span&gt;
    &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;maxProfit&lt;/span&gt;(&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;int&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;&amp;amp;prices&lt;/span&gt;) {
        &lt;span class="k"&gt;if&lt;/span&gt;(&lt;span class="n"&gt;prices&lt;/span&gt;.&lt;span class="n"&gt;size&lt;/span&gt;() &amp;lt; &lt;span class="mi"&gt;2&lt;/span&gt;) 
        {
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;;
        }
        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;price_diff&lt;/span&gt; = &lt;span class="mi"&gt;0&lt;/span&gt;;
        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cur_price&lt;/span&gt; = &lt;span class="n"&gt;prices&lt;/span&gt;[&lt;span class="mi"&gt;0&lt;/span&gt;];
        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="nb"&gt;sum&lt;/span&gt; = &lt;span class="mi"&gt;0&lt;/span&gt;;
        &lt;span class="k"&gt;for&lt;/span&gt;(&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; = &lt;span class="mi"&gt;1&lt;/span&gt;; &lt;span class="n"&gt;i&lt;/span&gt; &amp;lt; &lt;span class="n"&gt;prices&lt;/span&gt;.&lt;span class="n"&gt;size&lt;/span&gt;(); &lt;span class="n"&gt;i&lt;/span&gt;++)
        {
            &lt;span class="n"&gt;price_diff&lt;/span&gt; = &lt;span class="n"&gt;prices&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;]-&lt;span class="n"&gt;cur_price&lt;/span&gt;;
            &lt;span class="n"&gt;cur_price&lt;/span&gt; = &lt;span class="n"&gt;prices&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;];
            &lt;span class="k"&gt;if&lt;/span&gt;(&lt;span class="n"&gt;price_diff&lt;/span&gt; &amp;gt; &lt;span class="mi"&gt;0&lt;/span&gt;) &lt;span class="nb"&gt;sum&lt;/span&gt; += &lt;span class="n"&gt;price_diff&lt;/span&gt;;
        }
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;sum&lt;/span&gt;;
    }
};
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Leetcode Dynamic Programming"></category></entry><entry><title>Leetcode@Best Time to Buy and Sell Stock III</title><link href="http://www.zhangge208.com/pages/2015/05/26/leetcodebest-time-to-buy-and-sell-stock-iii.html" rel="alternate"></link><updated>2015-05-26T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-05-26:pages/2015/05/26/leetcodebest-time-to-buy-and-sell-stock-iii.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Leetcode@Best Time to Buy and Sell Stock III&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;/p&gt;
&lt;p&gt;Design an algorithm to find the maximum profit. You may complete at most two transactions.&lt;/p&gt;
&lt;p&gt;Note:
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;动态规划+前后遍历&lt;/p&gt;
&lt;p&gt;基本的想法是分成两个时间段，对于某一天j，计算之前的max profit和之后的max profit。&lt;/p&gt;
&lt;p&gt;即寻找一个点j，将原来的prices[0..n-1]分割成[0..j]和[j..n-1]两个子区间，分别求两段最大的收益，l_profit和r_profit，profit = l_profit + r_profit。然后用O(n)的时间在[0...n-1]上选择使得profit最大的j，返回最大的profit。&lt;/p&gt;
&lt;p&gt;对于点j，求price[0..j]的最大profit时，很多工作是重复的，在求price[0..j-1]的最大profit中已经做过了。Best Time to Buy and Sell Stock I的dp解法可以在O(1)的时间从price[0..j-1]推出price[0..j]的最大profit。
难点在于如何从price[j..n-1]推出price[j+1..n-1]，反过来思考，我们可以用O(1)的时间由price[j+1..n-1]推出price[j..n-1]。
所以进行前后遍历，即可得到结果。前后遍历的题目还有一些。&lt;/p&gt;
&lt;p&gt;整体思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组l[i]记录了price[0..i]的最大profit，&lt;/li&gt;
&lt;li&gt;数组r[i]记录了price[i..n]的最大profit。&lt;/li&gt;
&lt;li&gt;已知l[i]，求l[i+1]是简单的，同样已知r[i]，求r[i-1]也很容易。&lt;/li&gt;
&lt;li&gt;用O(n)的时间找出最大的l[i]+r[i]，即为题目所求。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Solution&lt;/span&gt; {
&lt;span class="n"&gt;public:&lt;/span&gt;
    &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;maxProfit&lt;/span&gt;(&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;int&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;&amp;amp;prices&lt;/span&gt;) {
        &lt;span class="k"&gt;if&lt;/span&gt;(&lt;span class="n"&gt;prices&lt;/span&gt;.&lt;span class="n"&gt;size&lt;/span&gt;() &amp;lt; &lt;span class="mi"&gt;2&lt;/span&gt;)
        {
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;;
        }
        &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;int&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;(&lt;span class="n"&gt;prices&lt;/span&gt;.&lt;span class="n"&gt;size&lt;/span&gt;());
        &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;int&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;(&lt;span class="n"&gt;prices&lt;/span&gt;.&lt;span class="n"&gt;size&lt;/span&gt;());
        // &lt;span class="n"&gt;DP&lt;/span&gt; &lt;span class="nb"&gt;from&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="nb"&gt;to&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;;
        &lt;span class="n"&gt;left&lt;/span&gt;[&lt;span class="mi"&gt;0&lt;/span&gt;] = &lt;span class="mi"&gt;0&lt;/span&gt;;
        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;min_price&lt;/span&gt; = &lt;span class="n"&gt;prices&lt;/span&gt;[&lt;span class="mi"&gt;0&lt;/span&gt;];
        &lt;span class="k"&gt;for&lt;/span&gt; (&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; = &lt;span class="mi"&gt;1&lt;/span&gt;; &lt;span class="n"&gt;i&lt;/span&gt; &amp;lt; &lt;span class="n"&gt;prices&lt;/span&gt;.&lt;span class="n"&gt;size&lt;/span&gt;(); &lt;span class="n"&gt;i&lt;/span&gt;++) 
        {
            &lt;span class="n"&gt;min_price&lt;/span&gt; = &lt;span class="nb"&gt;min&lt;/span&gt;(&lt;span class="n"&gt;prices&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;], &lt;span class="n"&gt;min_price&lt;/span&gt;);
            &lt;span class="n"&gt;left&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;] = &lt;span class="nb"&gt;max&lt;/span&gt;(&lt;span class="n"&gt;left&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt; - &lt;span class="mi"&gt;1&lt;/span&gt;], &lt;span class="n"&gt;prices&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;] - &lt;span class="n"&gt;min_price&lt;/span&gt;);            
        }

        //&lt;span class="n"&gt;DP&lt;/span&gt; &lt;span class="nb"&gt;from&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="nb"&gt;to&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;;
        &lt;span class="n"&gt;right&lt;/span&gt;[&lt;span class="mi"&gt;0&lt;/span&gt;] = &lt;span class="mi"&gt;0&lt;/span&gt;;
        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;max_price&lt;/span&gt; = &lt;span class="n"&gt;prices&lt;/span&gt;[&lt;span class="n"&gt;prices&lt;/span&gt;.&lt;span class="n"&gt;size&lt;/span&gt;() - &lt;span class="mi"&gt;1&lt;/span&gt;];
        &lt;span class="k"&gt;for&lt;/span&gt; (&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; = &lt;span class="n"&gt;prices&lt;/span&gt;.&lt;span class="n"&gt;size&lt;/span&gt;() - &lt;span class="mi"&gt;2&lt;/span&gt;; &lt;span class="n"&gt;i&lt;/span&gt; &amp;gt;= &lt;span class="mi"&gt;0&lt;/span&gt;; &lt;span class="n"&gt;i--&lt;/span&gt;)
        {
            &lt;span class="n"&gt;max_price&lt;/span&gt; = &lt;span class="nb"&gt;max&lt;/span&gt;(&lt;span class="n"&gt;prices&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;],&lt;span class="n"&gt;max_price&lt;/span&gt;);
            &lt;span class="n"&gt;right&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;] = &lt;span class="nb"&gt;max&lt;/span&gt;(&lt;span class="n"&gt;right&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;], &lt;span class="n"&gt;max_price&lt;/span&gt; - &lt;span class="n"&gt;prices&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;]);
        }

        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;profit&lt;/span&gt; = &lt;span class="mi"&gt;0&lt;/span&gt;;
        &lt;span class="k"&gt;for&lt;/span&gt; (&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; = &lt;span class="mi"&gt;0&lt;/span&gt;; &lt;span class="n"&gt;i&lt;/span&gt; &amp;lt; &lt;span class="n"&gt;prices&lt;/span&gt;.&lt;span class="n"&gt;size&lt;/span&gt;(); &lt;span class="n"&gt;i&lt;/span&gt;++)
        {
            &lt;span class="n"&gt;profit&lt;/span&gt; = &lt;span class="nb"&gt;max&lt;/span&gt;(&lt;span class="n"&gt;left&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;] +&lt;span class="n"&gt;right&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;], &lt;span class="n"&gt;profit&lt;/span&gt;);
        }

        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;profit&lt;/span&gt;;
    }
};
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Leetcode Dynamic Programming"></category></entry><entry><title>Leetcode@Majority Element</title><link href="http://www.zhangge208.com/pages/2015/05/26/leetcodemajority-element.html" rel="alternate"></link><updated>2015-05-26T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-05-26:pages/2015/05/26/leetcodemajority-element.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Leetcode@Majority Element&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.&lt;/p&gt;
&lt;p&gt;You may assume that the array is non-empty and the majority element always exist in the array.&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;抵消的思想，有一个假设的主元素candidate，计数器count，若为主元素，必须满足严格地大于n/2，那么当元素1（假设的主元素）与元素2不一样时，把这两个数均丢弃，count--,如果是主元素，仍然会剩下一些;当数1与数2相同时，count++;然而，在count == 0时，说明现在的元素并非是主元素，故令 candidate = num[i],重复以上过程。&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Solution&lt;/span&gt; {
&lt;span class="n"&gt;public:&lt;/span&gt;
    &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;majorityElement&lt;/span&gt;(&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;int&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;&amp;amp;num&lt;/span&gt;) {
        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;candidate&lt;/span&gt; = &lt;span class="mi"&gt;0&lt;/span&gt;;
        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="nb"&gt;count&lt;/span&gt; = &lt;span class="mi"&gt;0&lt;/span&gt;;
        &lt;span class="k"&gt;for&lt;/span&gt;(&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; = &lt;span class="mi"&gt;0&lt;/span&gt;;&lt;span class="n"&gt;i&lt;/span&gt; &amp;lt; &lt;span class="nb"&gt;num&lt;/span&gt;.&lt;span class="n"&gt;size&lt;/span&gt;(); &lt;span class="n"&gt;i&lt;/span&gt;++)
        {
            &lt;span class="k"&gt;if&lt;/span&gt;(&lt;span class="nb"&gt;count&lt;/span&gt; == &lt;span class="mi"&gt;0&lt;/span&gt;)
            {
                &lt;span class="n"&gt;candidate&lt;/span&gt; = &lt;span class="nb"&gt;num&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;];
            }

            &lt;span class="k"&gt;if&lt;/span&gt;(&lt;span class="n"&gt;candidate&lt;/span&gt; == &lt;span class="nb"&gt;num&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;])
            {
                &lt;span class="nb"&gt;count&lt;/span&gt;++;
            }

            &lt;span class="k"&gt;else&lt;/span&gt;
            {
                &lt;span class="n"&gt;count--&lt;/span&gt;;
            }
        }
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;candidate&lt;/span&gt;;
    }
};
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Leetcode HighFrequency"></category></entry><entry><title>Leetcode@Single Number</title><link href="http://www.zhangge208.com/pages/2015/05/26/leetcodesingle-number.html" rel="alternate"></link><updated>2015-05-26T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-05-26:pages/2015/05/26/leetcodesingle-number.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Leetcode@Single Number&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Given an array of integers, every element appears twice except for one. Find that single one.&lt;/p&gt;
&lt;p&gt;Note:
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;异或运算特点（不进位加法）:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a ^ b = c ,a ^ c = b -&amp;gt; b ^ c = a&lt;/li&gt;
&lt;li&gt;a ^ a = 0 （信息抵消）&lt;/li&gt;
&lt;li&gt;a ^ 0 = a&lt;/li&gt;
&lt;li&gt;(a ^ b) ^ c = a ^ (b ^ c)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据 a ^ a = 0,我们可以知道两个相同的数进行异或会相抵消，所以把数组中的所有数异或一遍即可得到答案&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Solution&lt;/span&gt; {
&lt;span class="n"&gt;public:&lt;/span&gt;
    &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;singleNumber&lt;/span&gt;(&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;[], &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;) {
        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="nb"&gt;num&lt;/span&gt; = &lt;span class="mi"&gt;0&lt;/span&gt;;
        &lt;span class="k"&gt;for&lt;/span&gt;(&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; = &lt;span class="mi"&gt;0&lt;/span&gt;; &lt;span class="n"&gt;i&lt;/span&gt; &amp;lt; &lt;span class="n"&gt;n&lt;/span&gt;; &lt;span class="n"&gt;i&lt;/span&gt;++)
        {
            &lt;span class="nb"&gt;num&lt;/span&gt; = &lt;span class="nb"&gt;num&lt;/span&gt; ^ &lt;span class="n"&gt;A&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;];
        }
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;num&lt;/span&gt;;
    }
};
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Leetcode HighFrequency"></category></entry><entry><title>Leetcode@Single Number II</title><link href="http://www.zhangge208.com/pages/2015/05/26/leetcodesingle-number-ii.html" rel="alternate"></link><updated>2015-05-26T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-05-26:pages/2015/05/26/leetcodesingle-number-ii.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Leetcode@Single Number II&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Given an array of integers, every element appears three times except for one. Find that single one.&lt;/p&gt;
&lt;p&gt;Note:
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;构造一个3进制的异或运算（XOR3），使得三个相同的数进行不进位加法（XOR3）后结果为0，与single number1的思路一样。&lt;/p&gt;</summary><category term="Algorithm Leetcode HighFrequency"></category></entry><entry><title>Leetcode@Climbing Stairs</title><link href="http://www.zhangge208.com/pages/2015/05/25/leetcodeclimbing-stairs.html" rel="alternate"></link><updated>2015-05-25T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-05-25:pages/2015/05/25/leetcodeclimbing-stairs.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Leetcode@Climbing Stairs&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;You are climbing a stair case. It takes n steps to reach to the top.&lt;/p&gt;
&lt;p&gt;Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;动态规划的思路，属于sequence DP&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;state: f[i]表示前i个位置，跳到第i个位置共有多少种方案&lt;/li&gt;
&lt;li&gt;function: f[i] = f[i-1] + f[i-2] （跳一步和跳两步）&lt;/li&gt;
&lt;li&gt;intialize: f[0] = 1, f[1] = 1&lt;/li&gt;
&lt;li&gt;answer: f[n]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;小陷阱：动态分配数组的时候要记得数组的大小应为0-n+1&lt;/p&gt;
&lt;p&gt;本题背后的故事实际上是斐波那契数列&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Solution&lt;/span&gt; {
&lt;span class="n"&gt;public:&lt;/span&gt;
    &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;climbStairs&lt;/span&gt;(&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;) {
        &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;int&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;(&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;);
        &lt;span class="n"&gt;res&lt;/span&gt;[&lt;span class="mi"&gt;0&lt;/span&gt;] = &lt;span class="mi"&gt;1&lt;/span&gt;;
        &lt;span class="n"&gt;res&lt;/span&gt;[&lt;span class="mi"&gt;1&lt;/span&gt;] = &lt;span class="mi"&gt;1&lt;/span&gt;;
        &lt;span class="k"&gt;for&lt;/span&gt;(&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; = &lt;span class="mi"&gt;2&lt;/span&gt;; &lt;span class="n"&gt;i&lt;/span&gt; &amp;lt;= &lt;span class="n"&gt;n&lt;/span&gt;; &lt;span class="n"&gt;i&lt;/span&gt;++)
        {
            &lt;span class="n"&gt;res&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;] = &lt;span class="n"&gt;res&lt;/span&gt;[&lt;span class="n"&gt;i-1&lt;/span&gt;] + &lt;span class="n"&gt;res&lt;/span&gt;[&lt;span class="n"&gt;i-2&lt;/span&gt;];
        }
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;[&lt;span class="n"&gt;n&lt;/span&gt;];
    }
};
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;节省空间的写法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;int climbStairs2(int n)  
{  
    vector&amp;lt;int&amp;gt; res(3);  
    res[0] = 1;  
    res[1] = 1;  
    for (int i = 2; i &amp;lt;= n; i++)  
    {  
        res[i%3] = res[(i-1)%3] + res[(i-2)%3];  
    }  
    return res[n%3];  
}
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Leetcode Dynamic Programming"></category></entry><entry><title>Leetcode@House Robber I</title><link href="http://www.zhangge208.com/pages/2015/05/25/leetcodehouse-robber-i.html" rel="alternate"></link><updated>2015-05-25T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-05-25:pages/2015/05/25/leetcodehouse-robber-i.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Leetcode@House Robber I&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.&lt;/p&gt;
&lt;p&gt;Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;属于序列动态规划(Sequence Dp)&lt;/p&gt;
&lt;p&gt;state：f[i]表示到第i个位置时可获得的最大利益&lt;/p&gt;
&lt;p&gt;function：f[i] = max(f[i-1], f[i-2]+nums[i])&lt;/p&gt;
&lt;p&gt;initialize: f[0] = nums[0], f[1] = max(f[0],nums[1])&lt;/p&gt;
&lt;p&gt;answer:f[n-1]&lt;/p&gt;
&lt;p&gt;异常处理，考虑边界情况，nums为空或长度为1的情况&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0){
            return 0;
        }
        int[] f = new int[nums.length];
        for (int i = 0; i &amp;lt; nums.length; i++){
            if (i == 0){
                f[0] = nums[0];
            }
            else if (i == 1){
                f[1] = Math.max(f[0],nums[1]);
            }
            else{
                f[i] = Math.max(f[i - 1],f[i - 2]+nums[i]);
            }
        }
        return f[nums.length - 1];
    }
}
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Leetcode Dynamic Programming"></category></entry><entry><title>Leetcode@House Robber II</title><link href="http://www.zhangge208.com/pages/2015/05/25/leetcodehouse-robber-ii.html" rel="alternate"></link><updated>2015-05-25T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-05-25:pages/2015/05/25/leetcodehouse-robber-ii.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Leetcode@House Robber II&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Note: This is an extension of House Robber.&lt;/p&gt;
&lt;p&gt;After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street.&lt;/p&gt;
&lt;p&gt;Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;题目变化导致的特殊判断条件为是否抢劫第一件房屋。如果是，则不能抢最后一件房屋。否则，可以抢最后一间房屋。&lt;/p&gt;
&lt;p&gt;以此为依据，将环形DP问题转化为两次序列DP问题&lt;/p&gt;
&lt;p&gt;异常处理，考虑边界情况，nums为空或长度为1的情况&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0){
            return 0;
        }
        if (nums.length == 1){
            return nums[0];
        }
        int prev = 0;
        int cur = 0;
        for (int i = 1; i &amp;lt; nums.length; i++){
            int temp = cur;
            cur = Math.max(cur, prev + nums[i]);
            prev = temp;
        }
        int missing_first = cur;

        prev = 0;
        cur = 0;
        for (int i = 0; i &amp;lt; nums.length - 1; i++){
            int temp = cur;
            cur = Math.max(cur, prev + nums[i]);
            prev = temp;
        }
        int missing_last = cur;

        return Math.max(missing_first,missing_last);
    }
}
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Leetcode Dynamic Programming"></category></entry><entry><title>来算法吧~</title><link href="http://www.zhangge208.com/pages/2015/01/04/lai-suan-fa-ba.html" rel="alternate"></link><updated>2015-01-04T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-01-04:pages/2015/01/04/lai-suan-fa-ba.html</id><summary type="html">&lt;p&gt;2015的第一季度要开始系统地学习算法，虽然只有不到一个月的假期！！！唉 ，不过把之前零零散散看的复习一下，然后还是有不少时间可是学到好多没看过的。不过呢，先慢慢来吧！
   我是想每天坚持写，坚持看，对某一个算法先理解基本的思想，算法运行的实际过程，给出代码实现，其实语言神马的，根本就不重要。。。然后会慢慢地进行算法分析，只是数学这东西，唉，不说了，说多了都是泪。最后给一些能运用到这种算法思想的小例子。说白了，也就是把leetcode和挑战程序设计竞赛上面的题目做会。
   就扯这么多吧！希望2015年，能够有突破性的进展！&lt;/p&gt;</summary><category term="Algorithm"></category></entry></feed>