<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Ant</title><link href="http://www.zhangge208.com/" rel="alternate"></link><link href="http://www.zhangge208.com/feeds/binary-search.atom.xml" rel="self"></link><id>http://www.zhangge208.com/</id><updated>2015-09-09T00:00:00+08:00</updated><entry><title>Binary Search</title><link href="http://www.zhangge208.com/pages/2015/09/09/binary-search.html" rel="alternate"></link><updated>2015-09-09T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-09-09:pages/2015/09/09/binary-search.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Binary Search&lt;/h1&gt;
&lt;h2&gt;基础模板&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.lintcode.com/zh-cn/problem/binary-search/"&gt;Binary Search&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;先给一个错误的示例，原来一直这样写，但在有重复元素时无法适用&lt;/p&gt;
&lt;p&gt;错误示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Solution&lt;/span&gt; {
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;binarySearch&lt;/span&gt;(&lt;span class="nb"&gt;int&lt;/span&gt;[] &lt;span class="n"&gt;nums&lt;/span&gt;, &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;target&lt;/span&gt;) {
        &lt;span class="k"&gt;if&lt;/span&gt; (&lt;span class="n"&gt;nums&lt;/span&gt; == &lt;span class="n"&gt;null&lt;/span&gt; || &lt;span class="n"&gt;nums&lt;/span&gt;.&lt;span class="n"&gt;length&lt;/span&gt; == &lt;span class="mi"&gt;0&lt;/span&gt;) {
            &lt;span class="k"&gt;return&lt;/span&gt; -&lt;span class="mi"&gt;1&lt;/span&gt;;
        }

        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt; = &lt;span class="mi"&gt;0&lt;/span&gt;;
        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="nb"&gt;end&lt;/span&gt; = &lt;span class="n"&gt;nums&lt;/span&gt;.&lt;span class="n"&gt;length&lt;/span&gt; - &lt;span class="mi"&gt;1&lt;/span&gt;;

        &lt;span class="k"&gt;while&lt;/span&gt; (&lt;span class="n"&gt;start&lt;/span&gt; &amp;lt;= &lt;span class="nb"&gt;end&lt;/span&gt;) {
            &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt; = &lt;span class="n"&gt;start&lt;/span&gt; + (&lt;span class="nb"&gt;end&lt;/span&gt; - &lt;span class="n"&gt;start&lt;/span&gt;) / &lt;span class="mi"&gt;2&lt;/span&gt;;
            &lt;span class="k"&gt;if&lt;/span&gt; (&lt;span class="n"&gt;nums&lt;/span&gt;[&lt;span class="n"&gt;mid&lt;/span&gt;] == &lt;span class="n"&gt;target&lt;/span&gt;) {
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt;;
            }
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; (&lt;span class="n"&gt;nums&lt;/span&gt;[&lt;span class="n"&gt;mid&lt;/span&gt;] &amp;lt; &lt;span class="n"&gt;target&lt;/span&gt;) {
                &lt;span class="n"&gt;start&lt;/span&gt; = &lt;span class="n"&gt;mid&lt;/span&gt;;
            }
            &lt;span class="k"&gt;else&lt;/span&gt; {
                &lt;span class="nb"&gt;end&lt;/span&gt; = &lt;span class="n"&gt;mid&lt;/span&gt;;
            }
        } 
        &lt;span class="k"&gt;return&lt;/span&gt; -&lt;span class="mi"&gt;1&lt;/span&gt;;
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;考虑下面的测试用例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;input：
[3,4,5,8,8,8,8,10,13,14], 8
output：
4
expect：
3
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在有重复元素时会出现问题&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.jiuzhang.com/solutions/binary-search/"&gt;Binary Search模板（参考九章算法）&lt;/a&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Solution&lt;/span&gt; {
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;binarySearch&lt;/span&gt;(&lt;span class="nb"&gt;int&lt;/span&gt;[] &lt;span class="n"&gt;nums&lt;/span&gt;, &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;target&lt;/span&gt;) {
        &lt;span class="k"&gt;if&lt;/span&gt; (&lt;span class="n"&gt;nums&lt;/span&gt; == &lt;span class="n"&gt;null&lt;/span&gt; || &lt;span class="n"&gt;nums&lt;/span&gt;.&lt;span class="n"&gt;length&lt;/span&gt; == &lt;span class="mi"&gt;0&lt;/span&gt;) {
            &lt;span class="k"&gt;return&lt;/span&gt; -&lt;span class="mi"&gt;1&lt;/span&gt;;
        }

        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt; = &lt;span class="mi"&gt;0&lt;/span&gt;;
        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="nb"&gt;end&lt;/span&gt; = &lt;span class="n"&gt;nums&lt;/span&gt;.&lt;span class="n"&gt;length&lt;/span&gt; - &lt;span class="mi"&gt;1&lt;/span&gt;;

        &lt;span class="k"&gt;while&lt;/span&gt; (&lt;span class="n"&gt;start&lt;/span&gt; + &lt;span class="mi"&gt;1&lt;/span&gt; &amp;lt; &lt;span class="nb"&gt;end&lt;/span&gt;) {
            &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt; = &lt;span class="n"&gt;start&lt;/span&gt; + (&lt;span class="nb"&gt;end&lt;/span&gt; - &lt;span class="n"&gt;start&lt;/span&gt;) / &lt;span class="mi"&gt;2&lt;/span&gt;;
            &lt;span class="k"&gt;if&lt;/span&gt; (&lt;span class="n"&gt;target&lt;/span&gt; &amp;lt; &lt;span class="n"&gt;nums&lt;/span&gt;[&lt;span class="n"&gt;mid&lt;/span&gt;]) {
                &lt;span class="nb"&gt;end&lt;/span&gt; = &lt;span class="n"&gt;mid&lt;/span&gt;;
            }
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; (&lt;span class="n"&gt;target&lt;/span&gt; &amp;gt; &lt;span class="n"&gt;nums&lt;/span&gt;[&lt;span class="n"&gt;mid&lt;/span&gt;]) {
                &lt;span class="n"&gt;start&lt;/span&gt; = &lt;span class="n"&gt;mid&lt;/span&gt;;
            }
            &lt;span class="k"&gt;else&lt;/span&gt; {
                &lt;span class="nb"&gt;end&lt;/span&gt; = &lt;span class="n"&gt;mid&lt;/span&gt;;
            }
        }

        &lt;span class="k"&gt;if&lt;/span&gt; (&lt;span class="n"&gt;nums&lt;/span&gt;[&lt;span class="n"&gt;start&lt;/span&gt;] == &lt;span class="n"&gt;target&lt;/span&gt;) {
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;;
        }
        &lt;span class="k"&gt;if&lt;/span&gt; (&lt;span class="n"&gt;nums&lt;/span&gt;[&lt;span class="nb"&gt;end&lt;/span&gt;] == &lt;span class="n"&gt;target&lt;/span&gt;) {
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;end&lt;/span&gt;;
        }

        &lt;span class="k"&gt;return&lt;/span&gt; -&lt;span class="mi"&gt;1&lt;/span&gt;;
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Keypoints：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对输入做异常处理：数组为空或者数组长度为0。&lt;/li&gt;
&lt;li&gt;int mid = start + (end - start) / 2 这种表示方法可以防止两个整型值相加时溢出。&lt;/li&gt;
&lt;li&gt;Recursion or While-Loop：使用迭代而不是递归进行二分查找，因为工程中递归写法存在潜在溢出的可能&lt;/li&gt;
&lt;li&gt;while循环终止条件：while终止条件应为start + 1 &amp;lt; end而不是start &amp;lt;= end，start == end时可能出现死循环，即循环终止条件是相邻或相交元素时退出。配合while终止条件start + 1 &amp;lt; end（相邻即退出）的赋值语句mid永远没有+1或者-1，这样不会死循环。&lt;/li&gt;
&lt;li&gt;迭代终止时target应为start或者end中的一个。循环终止条件有两个，具体应看是找第一个还是最后一个而定。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Problem List&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.zhangge208.com/pages/2015/09/09/search-insert-position.html"&gt;Search Insert Position&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhangge208.com/pages/2015/09/09/search-for-a-range.html"&gt;Search for a Range&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhangge208.com/pages/2015/09/09/search-in-rotated-sorted-array.html"&gt;Search in Rotated Sorted Array&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=""&gt;Search in Rotated Sorted Array II&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhangge208.com/pages/2015/09/09/search-a-2d-matrix.html"&gt;Search a 2D Matrix&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhangge208.com/pages/2015/09/09/search-a-2d-matrix-ii.html"&gt;Search a 2D Matrix II&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhangge208.com/pages/2015/09/09/first-bad-version.html"&gt;First Bad Version&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhangge208.com/pages/2015/09/09/find-peak-element.html"&gt;Find Peak Element&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhangge208.com/pages/2015/09/09/find-minimum-in-rotated-sorted-array.html"&gt;Find Minimum in Rotated Sorted Array&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=""&gt;Find Minimum in Rotated Sorted Array II&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhangge208.com/pages/2015/09/09/minimum-size-subarray-sum.html"&gt;Minimum Size Subarray Sum&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhangge208.com/pages/2015/09/09/h-index-ii.html"&gt;H-Index II&lt;/a&gt;&lt;/p&gt;</summary><category term="Algorithm Binary Search"></category></entry><entry><title>Find Minimum in Rotated Sorted Array</title><link href="http://www.zhangge208.com/pages/2015/09/09/find-minimum-in-rotated-sorted-array.html" rel="alternate"></link><updated>2015-09-09T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-09-09:pages/2015/09/09/find-minimum-in-rotated-sorted-array.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Find Minimum in Rotated Sorted Array&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Suppose a sorted array is rotated at some pivot unknown to you beforehand.&lt;/p&gt;
&lt;p&gt;(i.e., &lt;code&gt;0 1 2 4 5 6 7&lt;/code&gt; might become &lt;code&gt;4 5 6 7 0 1 2&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Find the minimum element.&lt;/p&gt;
&lt;p&gt;You may assume no duplicate exists in the array.&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public int findMin(int[] nums) {
        if (nums == null || nums.length == 0) {
            return -1;
        }

        int start = 0;
        int end = nums.length - 1;

        while (start + 1 &amp;lt; end) {
            int mid =start + (end - start) / 2;
            if (nums[mid] &amp;gt; nums[end]) {
                start = mid;
            }
            else {
                end = mid;
            }
        }
        return nums[start] &amp;lt; nums[end] ? nums[start] : nums[end];
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;与Search in Rotated Sorted Array很类似，但我们是需要寻找最小元素，那么最小元素的位置该如何确定？&lt;/p&gt;
&lt;p&gt;只需判断nums[mid]和nums[end]的大小，如果nums[mid] &amp;gt; nums[end]，表明前半部分有序，那么最小元素一定在后半部分，反之nums[mid] &amp;lt; nums[end]表明后半部分有序，最小元素在前半部分，依据这个核心思路，利用二分搜索模板即可。&lt;/p&gt;</summary><category term="Algorithm Binary Search"></category></entry><entry><title>Find Peak Element</title><link href="http://www.zhangge208.com/pages/2015/09/09/find-peak-element.html" rel="alternate"></link><updated>2015-09-09T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-09-09:pages/2015/09/09/find-peak-element.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Find Peak Element&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;A peak element is an element that is greater than its neighbors.&lt;/p&gt;
&lt;p&gt;Given an input array where &lt;code&gt;num[i] ≠ num[i+1]&lt;/code&gt;, find a peak element and return its index.&lt;/p&gt;
&lt;p&gt;The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.&lt;/p&gt;
&lt;p&gt;You may imagine that &lt;code&gt;num[-1] = num[n] = -∞&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example, in array &lt;code&gt;[1, 2, 3, 1]&lt;/code&gt;, 3 is a peak element and your function should return the index number 2.&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public int findPeakElement(int[] num) {
         int start = 0, end = num.length - 1;  
         while(start + 1 &amp;lt; end) {
            int mid = start + (end - start) / 2;
            if(num[mid] &amp;gt; num[mid - 1] &amp;amp;&amp;amp; num[mid] &amp;gt; num[mid + 1]) {
                end = mid;
            } 
            else if(num[mid] &amp;lt; num[mid + 1]) {
                start = mid;
            } 
            else {
                end = mid;
            }
        }
        if(num[start] &amp;lt; num[end]) {
            return end;
        } 
        else { 
            return start;
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;寻找局部的最大值，二分搜索&lt;/p&gt;
&lt;p&gt;需要对二分搜索的模板进行一下改动&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果num[i-1] &amp;lt; num[i] &amp;gt; num[i+1], 那么num[i]是峰值元素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果num[i-1] &amp;lt; num[i] &amp;lt; num[i+1], 那么num[i+1...n-1]一定包含一个峰值元素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果num[i-1] &amp;gt; num[i] &amp;gt; num[i+1], 那么num[0...i-1]一定包含一个峰值元素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果num[i-1] &amp;gt; num[i] &amp;lt; num[i+1], 那么任意一边都可能有峰值元素&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Algorithm Binary Search"></category></entry><entry><title>First Bad Version</title><link href="http://www.zhangge208.com/pages/2015/09/09/first-bad-version.html" rel="alternate"></link><updated>2015-09-09T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-09-09:pages/2015/09/09/first-bad-version.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;First Bad Version&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.&lt;/p&gt;
&lt;p&gt;Suppose you have &lt;code&gt;n&lt;/code&gt; versions &lt;code&gt;[1, 2, ..., n]&lt;/code&gt; and you want to find out the first bad one, which causes all the following ones to be bad.&lt;/p&gt;
&lt;p&gt;You are given an API &lt;code&gt;bool isBadVersion(version)&lt;/code&gt; which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* The isBadVersion API is defined in the parent class VersionControl.&lt;/span&gt;
&lt;span class="cm"&gt;      boolean isBadVersion(int version); */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

public&lt;span class="w"&gt; &lt;/span&gt;class&lt;span class="w"&gt; &lt;/span&gt;Solution&lt;span class="w"&gt; &lt;/span&gt;extends&lt;span class="w"&gt; &lt;/span&gt;VersionControl&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;public&lt;span class="w"&gt; &lt;/span&gt;int&lt;span class="w"&gt; &lt;/span&gt;firstBadVersion&lt;span class="o"&gt;(&lt;/span&gt;int&lt;span class="w"&gt; &lt;/span&gt;n&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;n&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;int&lt;span class="w"&gt; &lt;/span&gt;start&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;int&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;end&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;n&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;start&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;end&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;int&lt;span class="w"&gt; &lt;/span&gt;mid&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;start&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;end&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;start&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;isBadVersion&lt;span class="o"&gt;(&lt;/span&gt;mid&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;false&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;start&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;mid&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kr"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="kr"&gt;end&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;mid&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;isBadVersion&lt;span class="o"&gt;(&lt;/span&gt;start&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;true&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;start&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;isBadVersion&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;end&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;true&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;end&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;很基础的二分搜索，先要判断mid处的版本是否是bad version，如果不是，那么前半部分均可以不要，start = mid。套用二分法模板就好&lt;/p&gt;</summary><category term="Algorithm Binary Search"></category></entry><entry><title>H-Index II</title><link href="http://www.zhangge208.com/pages/2015/09/09/h-index-ii.html" rel="alternate"></link><updated>2015-09-09T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-09-09:pages/2015/09/09/h-index-ii.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;H-Index II&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Follow up&lt;/strong&gt; for &lt;a href="https://leetcode.com/problems/h-index/"&gt;H-Index&lt;/a&gt;: What if the &lt;code&gt;citations&lt;/code&gt; array is sorted in ascending order? Could you optimize your algorithm?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hint:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Expected runtime complexity is in O(log n) and the input is sorted.&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public int hIndex(int[] citations) {
        if (citations == null || citations.length == 0) {
            return 0;
        }

        int start = 0;
        int end = citations.length - 1;
        while (start + 1 &amp;lt; end) {
            int mid = start + (end - start) / 2;
            if (citations[mid] == citations.length - mid) {
                return citations.length - mid;
            }
            else if (citations[mid] &amp;lt; citations.length - mid) {
                start = mid;
            }
            else {
                end = mid;
            }
        }

        if (citations[start] &amp;gt;= citations.length - start) {
            return citations.length - start;
        }
        if (citations[end] &amp;gt;= citations.length - end) {
            return citations.length - end;
        }
        return 0;
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;O(log n)的复杂度，排序的数组输入，那么一定是二分搜索无疑了，但在模板上应该做什么样的改动呢？&lt;/p&gt;
&lt;p&gt;关键就在于h因子的定义：被引用次数等于或超过h的文章至少有h篇&lt;/p&gt;
&lt;p&gt;如果定义数组长度为n的话，最后h篇文章被引用次数应该等于或超过h，那么也就是说第n - h篇文章被引用次数应该等于或超过h，即：&lt;/p&gt;
&lt;p&gt;citations[n - h] &amp;gt;= h &lt;/p&gt;
&lt;p&gt;如果令mid = n - h，这样就可以使用二分搜索：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果citations[mid] == citations.length - mid，那么citations.length - mid即为h因子&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果citations[mid] &amp;lt; citations.length - mid，那么说明选择的mid太小，第n - h篇文章并不能满足等于或超过h，需要后移&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果citations[mid] &amp;gt; citations.length - mid，那么说明选择的mid太大，第n - h篇之前的文章就能满足等于或超过h，需要前移&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;边界条件：判断start、end两个特殊点哪个满足条件&lt;/p&gt;</summary><category term="Algorithm Binary Search"></category></entry><entry><title>Search a 2D Matrix</title><link href="http://www.zhangge208.com/pages/2015/09/09/search-a-2d-matrix.html" rel="alternate"></link><updated>2015-09-09T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-09-09:pages/2015/09/09/search-a-2d-matrix.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Search a 2D Matrix&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:&lt;/p&gt;
&lt;p&gt;Integers in each row are sorted from left to right.
The first integer of each row is greater than the last integer of the previous row.
For example,&lt;/p&gt;
&lt;p&gt;Consider the following matrix:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;[
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Given &lt;strong&gt;target&lt;/strong&gt; = &lt;code&gt;3&lt;/code&gt;, return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return false;
        }
        int row = matrix.length;
        int col = matrix[0].length;
        int start = 0;
        int end = row * col - 1;
        while (start + 1 &amp;lt; end) {
            int mid = start + (end - start) / 2;
            int x = mid / col ;
            int y = mid % col ;
            if (matrix[x][y] == target) {
                end = mid;
            }
            else if (matrix[x][y] &amp;lt; target) {
                start = mid;
            }
            else {
                end = mid;
            }
        }
        if (matrix[start / col][start % col] == target) {
            return true;
        }
        if (matrix[end / col][end % col] == target) {
            return true;
        }

        return false;
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;参考Python中用列表表示多维数组的想法，可以将整个二维数组展成一维的数组，这样直接使用二分搜索就可以了。&lt;/p&gt;
&lt;p&gt;一个小trick:如何用mid表示二维数组的下标呢？&lt;/p&gt;
&lt;p&gt;answer：行下标为mid / col,列下标为mid % col&lt;/p&gt;</summary><category term="Algorithm Binary Search"></category></entry><entry><title>Search a 2D Matrix II</title><link href="http://www.zhangge208.com/pages/2015/09/09/search-a-2d-matrix-ii.html" rel="alternate"></link><updated>2015-09-09T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-09-09:pages/2015/09/09/search-a-2d-matrix-ii.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Search a 2D Matrix II&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:&lt;/p&gt;
&lt;p&gt;Integers in each row are sorted in ascending from left to right.
Integers in each column are sorted in ascending from top to bottom.
For example,&lt;/p&gt;
&lt;p&gt;Consider the following matrix:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Given &lt;strong&gt;target&lt;/strong&gt; = 5, return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Given &lt;strong&gt;target&lt;/strong&gt; = 20, return &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0) {
            return false;
        }

        if (matrix[0] == null || matrix[0].length == 0) {
            return false;
        }

        int rowBegin = 0;
        int rowEnd = matrix.length - 1;
        int colBegin = 0;
        int colEnd = matrix[0].length - 1;

        while(colEnd &amp;gt;= colBegin &amp;amp;&amp;amp; rowBegin &amp;lt;= rowEnd) {
            int temp = matrix[rowBegin][colEnd];
            if(target == temp) {
                return true;
            }
            else if (target &amp;lt; temp) {
                colEnd--;
            }
            else if (target &amp;gt; temp) {
                rowBegin++;
            }

        }

        return false;
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;这道题目的难度主要在于并不是全部有序的，仅存在行有序与列有序，这时需要观察数组的特殊元素，例如四个角上的元素，并且选择的特殊元素能使用上有序的属性。那么左上角和右下角的元素就不合适了，左上角的元素是数组中最小的，右下角元素是数组中最大的。而右上角元素在这一行中是最大的，但在列中却是这一列最小的。左下角也一样，在列排序中是最大的，在行排序中是最小的。代码中选择的是右上角元素，在target小于该元素时，移动列下标，在更小的一列寻找target，而在target大于该元素时，那么移动行下标，在更大的一行寻找target&lt;/p&gt;</summary><category term="Algorithm Binary Search"></category></entry><entry><title>Search for a Range</title><link href="http://www.zhangge208.com/pages/2015/09/09/search-for-a-range.html" rel="alternate"></link><updated>2015-09-09T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-09-09:pages/2015/09/09/search-for-a-range.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Search for a Range&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Given a sorted array of integers, find the starting and ending position of a given target value.&lt;/p&gt;
&lt;p&gt;Your algorithm's runtime complexity must be in the order of O(log n).&lt;/p&gt;
&lt;p&gt;If the target is not found in the array, return &lt;code&gt;[-1, -1]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example,
Given &lt;code&gt;[5, 7, 7, 8, 8, 10]&lt;/code&gt; and target value 8,
return &lt;code&gt;[3, 4]&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public int[] searchRange(int[] nums, int target) {
        int[] result = new int[2];
        if (nums == null || nums.length == 0) {
            return result;
        }
        //search for left bound
        int start = 0;
        int end = nums.length - 1;
        int mid = 0;
        while (start + 1 &amp;lt; end) {
            mid = start + (end - start) / 2;
            if (target == nums[mid]) {
                end = mid;        
            }
            else if (target &amp;gt; nums[mid]) {
                start = mid;
            }
            else {
                end = mid;
            }
        }
        if (nums[start] == target) {
            result[0] = start;
        }
        else if (nums[end] == target) {
            result[0] = end;
        }
        else {
            result[0] = result[1] = -1;
            return result;
        }

        start = 0;
        end = nums.length - 1;
        while (start + 1 &amp;lt; end) {
            mid = start + (end - start) / 2;
            if (target == nums[mid]) {
                start = mid;        
            }
            else if (target &amp;gt; nums[mid]) {
                start = mid;
            }
            else {
                end = mid;
            }

        }
        if (nums[end] == target) {
            result[1] = end;
        }
        else if (nums[start] == target){
            result[1] = start;
        }
        else {
            result[0] = result[1] = -1;
            return result;
        }
        return result;

    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;这道题目是练习寻找二分搜索的边界。运用二分搜索模板可以找到左边界，那么该如何寻找右边界呢，只需要将模板稍稍修改即可，寻找左边界时，
如果target == nums[mid]，那么令end = mid；寻找右边界时，
如果target == nums[mid]，那么令start = mid。想想其中原因，若二分法的end越小，则越靠近左边，而start越大则越靠近右边。故寻找到了左右边界。&lt;br /&gt;
&lt;/p&gt;</summary><category term="Algorithm Binary Search"></category></entry><entry><title>Search in Rotated Sorted Array</title><link href="http://www.zhangge208.com/pages/2015/09/09/search-in-rotated-sorted-array.html" rel="alternate"></link><updated>2015-09-09T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-09-09:pages/2015/09/09/search-in-rotated-sorted-array.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Search in Rotated Sorted Array&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Suppose a sorted array is rotated at some pivot unknown to you beforehand.&lt;/p&gt;
&lt;p&gt;(i.e., &lt;code&gt;0 1 2 4 5 6 7&lt;/code&gt; might become &lt;code&gt;4 5 6 7 0 1 2&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;You are given a target value to search. If found in the array return its index, otherwise return -1.&lt;/p&gt;
&lt;p&gt;You may assume no duplicate exists in the array.&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public int search(int[] nums, int target) {
        if (nums.length == 0 || nums == null) {
            return -1;
        }

        int start = 0;
        int end = nums.length - 1;

        while (start + 1 &amp;lt; end) {
            int mid = start + (end - start) / 2;
            if (nums[mid] == target) {
                end = mid;
            }
            else if (nums[mid] &amp;lt; nums[end]) {
                if (nums[mid] &amp;lt;= target &amp;amp;&amp;amp; target &amp;lt;= nums[end]) {
                    start = mid;
                }
                else {
                    end = mid;
                }
            }
            // nums[mid] &amp;gt; nums[start]
            else {
                if (nums[mid] &amp;gt;= target &amp;amp;&amp;amp; target &amp;gt;= nums[start]) {
                    end = mid;
                }
                else {
                    start = mid;
                }
            }
        }

        if (nums[start] == target) {
            return start;
        }
        if (nums[end] == target) {
            return end;
        }

        return -1;

    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;在数组发生旋转后会有两种情况产生，以[0,1,2,3,4,5,6]为例：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;旋转后形如[3,4,5,6,0,1,2],即较小的数发生了翻转，但前半部分仍然有序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;旋转后形如[5,6,0,1,2,3,4],即较大的数发生了翻转，但后半部分仍然有序&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为使用二分搜索，那么必须保持使用区间的有序性,所以要在nums[mid] &amp;lt;= target &amp;amp;&amp;amp; target &amp;lt;= nums[end] 或 nums[mid] &amp;gt;= target &amp;amp;&amp;amp; target &amp;gt;= nums[start]这两个有序部分进行二分搜索&lt;/p&gt;</summary><category term="Algorithm Binary Search"></category></entry><entry><title>Search Insert Position</title><link href="http://www.zhangge208.com/pages/2015/09/09/search-insert-position.html" rel="alternate"></link><updated>2015-09-09T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-09-09:pages/2015/09/09/search-insert-position.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Search Insert Position&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.&lt;/p&gt;
&lt;p&gt;You may assume no duplicates in the array.&lt;/p&gt;
&lt;p&gt;Here are few examples.
[1,3,5,6], 5 → 2&lt;/p&gt;
&lt;p&gt;[1,3,5,6], 2 → 1&lt;/p&gt;
&lt;p&gt;[1,3,5,6], 7 → 4&lt;/p&gt;
&lt;p&gt;[1,3,5,6], 0 → 0&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;version 1：first postion &amp;gt;= target
public class Solution {
    public int searchInsert(int[] nums, int target) {
        if (nums == null || nums.length == 0) {
            return -1;
        }
        int start = 0;
        int end = nums.length - 1;
        while (start + 1 &amp;lt; end) {
            int mid = start + (end - start) / 2;
            if (target &amp;lt; nums[mid]) {
                end = mid;
            }
            else if (target &amp;gt; nums[mid]) {
                start = mid;
            }
            else {
                end = mid;
            }
        }

        if (nums[start] &amp;gt;= target) {
            return start;
        }
        else if (nums[end] &amp;gt;= target) {
            return end;
        }
        //nums[end] &amp;lt; target
        else {
            return end + 1;
        }

    }
}

version 2：last postion &amp;lt; target
public class Solution {
    public int searchInsert(int[] nums, int target) {
        if (nums == null || nums.length == 0) {
            return -1;
        }

        int start = 0;
        int end = nums.length - 1;
        while (start + 1 &amp;lt; end) {
            int mid = start + (end -start) / 2;
            if (target &amp;gt; nums[mid]) {
                start = mid;
            }
            else {
                end = mid;
            }
        }
        if (target &amp;lt; nums[0]) {
            return 0;
        }
        if (nums[start] == target) {
            return start;
        }
        if (nums[end] == target) {
            return end;
        }   
        if (nums[end] &amp;lt; target){
            return end + 1;
        }
        return start + 1;
    }
 }
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;如果target在数组中，那么可直接运用二分搜索的模板，但需要处理的一个问题是，如果target不在数组中，那么应该把它放在哪里合适呢？
直接地，有两种思路：&lt;/p&gt;
&lt;p&gt;1.找到first postion &amp;gt;= target的地方，把target放在这个位置&lt;/p&gt;
&lt;p&gt;2.找到last postion &amp;lt; target的地方，把target放在这个位置&lt;/p&gt;
&lt;p&gt;值得注意的是，对一些边界的问题需要进行考虑&lt;/p&gt;
&lt;p&gt;1.使用第一种思路时，要注意处理nums[end] &amp;lt; target的情况&lt;/p&gt;
&lt;p&gt;2.使用第二种思路时，要注意处理target &amp;lt; nums[0]的情况&lt;/p&gt;</summary><category term="Algorithm Binary Search"></category></entry><entry><title>Leetcode@Search in Rotated Sorted Array II</title><link href="http://www.zhangge208.com/pages/2015/01/19/leetcodesearch-in-rotated-sorted-array-ii.html" rel="alternate"></link><updated>2015-01-19T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-01-19:pages/2015/01/19/leetcodesearch-in-rotated-sorted-array-ii.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;题目&lt;/h1&gt;
&lt;p&gt;Follow up for "Search in Rotated Sorted Array":
What if duplicates are allowed?&lt;/p&gt;
&lt;p&gt;Would this affect the run-time complexity? How and why?&lt;/p&gt;
&lt;p&gt;Write a function to determine if a given target is in the array.&lt;/p&gt;
&lt;h1&gt;解题思路&lt;/h1&gt;
&lt;p&gt;在上一题”Search in Rotated Array“中假设数组不会出现重复元素。但如果允许出现重复的元素，那么对中间和边缘相等的情况需要进行特殊的处理。原来的题目通过中间与边缘元素的比较来判断哪一半为有序的，但现在出现了重复，这导致若边缘与中间相等，将无法判断有序部分的情况，例如,原来为[1,2,3,4,4,4,4,4,4],翻转后变为[4,4,4,4,4,1,2,3,4],这样一来，无论中心边缘都相等，在寻找1或2时，根本无法判断应跳向哪一步。为解决这一问题，只有将边缘移动一步，直到边缘和中间不再相等，或者中间与边缘已经重合。在最坏情况时，即序列为同一元素时，时间复杂度会退化至O(n)。&lt;/p&gt;
&lt;h1&gt;代码&lt;/h1&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Solution&lt;/span&gt;{
&lt;span class="n"&gt;public:&lt;/span&gt;
    &lt;span class="nb"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;search&lt;/span&gt;(&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;[], &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;, &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;target&lt;/span&gt;) {
        &lt;span class="k"&gt;if&lt;/span&gt;(&lt;span class="n"&gt;NULL&lt;/span&gt; == &lt;span class="n"&gt;A&lt;/span&gt; || &lt;span class="mi"&gt;0&lt;/span&gt; == &lt;span class="n"&gt;n&lt;/span&gt;)  
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;false&lt;/span&gt;;  
        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt; = &lt;span class="mi"&gt;0&lt;/span&gt;, &lt;span class="n"&gt;right&lt;/span&gt; = &lt;span class="n"&gt;n-1&lt;/span&gt;, &lt;span class="n"&gt;mid&lt;/span&gt; = &lt;span class="mi"&gt;0&lt;/span&gt;;  
        &lt;span class="k"&gt;while&lt;/span&gt;(&lt;span class="n"&gt;left&lt;/span&gt; &amp;lt;= &lt;span class="n"&gt;right&lt;/span&gt;)  
        {  
            &lt;span class="n"&gt;mid&lt;/span&gt; = &lt;span class="n"&gt;left&lt;/span&gt;+(&lt;span class="n"&gt;right-left&lt;/span&gt;)/&lt;span class="mi"&gt;2&lt;/span&gt;;  
            &lt;span class="k"&gt;if&lt;/span&gt;(&lt;span class="n"&gt;A&lt;/span&gt;[&lt;span class="n"&gt;mid&lt;/span&gt;] == &lt;span class="n"&gt;target&lt;/span&gt;)  
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;;
            &lt;span class="k"&gt;if&lt;/span&gt;(&lt;span class="n"&gt;A&lt;/span&gt;[&lt;span class="n"&gt;mid&lt;/span&gt;] &amp;gt; &lt;span class="n"&gt;A&lt;/span&gt;[&lt;span class="n"&gt;left&lt;/span&gt;])
            {
                &lt;span class="k"&gt;if&lt;/span&gt;(&lt;span class="n"&gt;target&lt;/span&gt; &amp;lt; &lt;span class="n"&gt;A&lt;/span&gt;[&lt;span class="n"&gt;mid&lt;/span&gt;] &amp;amp;&amp;amp; &lt;span class="n"&gt;target&lt;/span&gt; &amp;gt;=&lt;span class="n"&gt;A&lt;/span&gt;[&lt;span class="n"&gt;left&lt;/span&gt;])
                {
                    &lt;span class="n"&gt;right&lt;/span&gt; = &lt;span class="n"&gt;mid&lt;/span&gt; - &lt;span class="mi"&gt;1&lt;/span&gt;;
                }
                &lt;span class="k"&gt;else&lt;/span&gt;
                {
                    &lt;span class="n"&gt;left&lt;/span&gt; = &lt;span class="n"&gt;mid&lt;/span&gt; + &lt;span class="mi"&gt;1&lt;/span&gt;;
                }
            }
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; (&lt;span class="n"&gt;A&lt;/span&gt;[&lt;span class="n"&gt;mid&lt;/span&gt;]&amp;lt; &lt;span class="n"&gt;A&lt;/span&gt;[&lt;span class="n"&gt;left&lt;/span&gt;])
            {
                &lt;span class="k"&gt;if&lt;/span&gt;(&lt;span class="n"&gt;target&lt;/span&gt; &amp;gt;&lt;span class="n"&gt;A&lt;/span&gt;[&lt;span class="n"&gt;mid&lt;/span&gt;] &amp;amp;&amp;amp; &lt;span class="n"&gt;A&lt;/span&gt;[&lt;span class="n"&gt;right&lt;/span&gt;] &amp;gt;= &lt;span class="n"&gt;target&lt;/span&gt; )
                {
                    &lt;span class="n"&gt;left&lt;/span&gt; = &lt;span class="n"&gt;mid&lt;/span&gt; +&lt;span class="mi"&gt;1&lt;/span&gt;;
                }
                &lt;span class="k"&gt;else&lt;/span&gt;
                {
                    &lt;span class="n"&gt;right&lt;/span&gt; = &lt;span class="n"&gt;mid&lt;/span&gt; -&lt;span class="mi"&gt;1&lt;/span&gt;;
                }
            }
            &lt;span class="k"&gt;else&lt;/span&gt;
            {
                &lt;span class="n"&gt;left&lt;/span&gt; = &lt;span class="n"&gt;left&lt;/span&gt; + &lt;span class="mi"&gt;1&lt;/span&gt;;
            }
        }
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;false&lt;/span&gt;;
    }

};
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Binary Search"></category></entry></feed>