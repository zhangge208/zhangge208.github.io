<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Ant</title><link href="http://www.zhangge208.com/" rel="alternate"></link><link href="http://www.zhangge208.com/feeds/zhangge208.atom.xml" rel="self"></link><id>http://www.zhangge208.com/</id><updated>2015-12-15T00:00:00+08:00</updated><entry><title>Binary Tree</title><link href="http://www.zhangge208.com/pages/2015/12/15/binary-tree.html" rel="alternate"></link><updated>2015-12-15T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-12-15:pages/2015/12/15/binary-tree.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Binary Tree&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;讲义的思路为参加&lt;a href="http://www.jiuzhang.com"&gt;九章算法&lt;/a&gt;培训学习，部分代码、模板均有所参考&lt;/p&gt;
&lt;p&gt;特别感谢前辈：&lt;a href="http://www.shuatiblog.com/"&gt;http://www.shuatiblog.com/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Outline&lt;/h2&gt;
&lt;p&gt;1.Binary Tree DFS Traversal&lt;/p&gt;
&lt;p&gt;-preorder/inorder/postorder&lt;/p&gt;
&lt;p&gt;-Divide &amp;amp; Conquer&lt;/p&gt;
&lt;p&gt;-DFS Template&lt;/p&gt;
&lt;p&gt;2.Binary Tree BFS Traversal&lt;/p&gt;
&lt;p&gt;-BFS Template&lt;/p&gt;
&lt;p&gt;3.Binary Search Tree&lt;/p&gt;
&lt;h2&gt;Binary Tree DFS Traversal&lt;/h2&gt;
&lt;h3&gt;三种基本遍历方法&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    A
   / \
  B   C
 / \  
D   E
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;前序(Preorder)：A BDE C&lt;/p&gt;
&lt;p&gt;中序(Inorder)：DBE A C&lt;/p&gt;
&lt;p&gt;后序(Postorder)：DEB C A&lt;/p&gt;
&lt;h3&gt;递归 or 非递归？&lt;/h3&gt;
&lt;p&gt;递归的办法会很简单，一般来说不推荐，然而，Done is better than Perfect！&lt;/p&gt;
&lt;h3&gt;Divide &amp;amp; Conquer Algorithm&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Merge Sort&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Quick Sort&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;适用于大多数的Binary Tree Problem&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分治法对于二叉树问题，进行如下的操作：&lt;/p&gt;
&lt;p&gt;1.&lt;strong&gt;Divide&lt;/strong&gt;：对于左右子树分别去同时处理，将原问题划分成为更小的子问题&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;Conquer&lt;/strong&gt;：将子问题的解合并，返回问题的解&lt;/p&gt;
&lt;h3&gt;Binary Tree DFS Template&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Template 1:Traverse

public class Solution {
    public void traverse(TreeNode root) {
        if (root == null) {
            return ;
        }
    //do something with root
    traverse(root.left);
    //do something with root
    traverse(root.right);
    //do something with root
    }
}

Template 2:Divide &amp;amp; Conquer

public class Solution {
    public ResultType traversal(TreeNode root) {
        // null or leaf
        if (root = null) {
            //do something and return;
        }

        //Divide
        ResultType left = traversal(root.left);
        ResultType right = traversal(root.right);

        //Conquer
        ResultType result = Merge from left and right;
        return result;
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Problem List&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Traversal&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http:"&gt;Binary Tree Preorder Traversal&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http:"&gt;Binary Tree Inorder Traversal&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http:"&gt;Binary Tree Postorder Traversal&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Divide &amp;amp; Conquer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http:"&gt;Maximum Depth of Binary Tree&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http:"&gt;Minimum Depth of Binary Tree&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http:"&gt;Balanced Binary Tree&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http:"&gt;Binary Tree Maximum Path Sum&lt;/a&gt; – &lt;strong&gt;the most important question&lt;/strong&gt; &lt;/p&gt;</summary><category term="Algorithm Binary Tree"></category></entry><entry><title>Leetcode@Binary Tree Inorder Traversal</title><link href="http://www.zhangge208.com/pages/2015/12/15/leetcodebinary-tree-inorder-traversal.html" rel="alternate"></link><updated>2015-12-15T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-12-15:pages/2015/12/15/leetcodebinary-tree-inorder-traversal.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Binary Tree Inorder Traversal&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Given a binary tree, return the inorder traversal of its nodes' values.&lt;/p&gt;
&lt;p&gt;For example:
Given binary tree {1,#,2,3},&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;   1
    \
     2
    /
   3
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;return [1,3,2].&lt;/p&gt;
&lt;p&gt;Note: Recursive solution is trivial, could you do it iteratively?&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;三种做法：1.非递归（推荐） 2.递归：遍历 3.递归：分治法&lt;/p&gt;
&lt;h3&gt;非递归&lt;/h3&gt;
&lt;p&gt;运用栈和迭代。值得注意的是，入栈的先后顺序，栈是先入后出的数据结构，为保证是中序遍历，首先需要对左子树进行迭代并将非空节点入栈，直到节点为空，当前节点为空时进行出栈操作，并访问栈顶节点，将当前节点用右子节点代替。&lt;/p&gt;
&lt;h3&gt;递归：遍历&lt;/h3&gt;
&lt;p&gt;运用遍历的方法&lt;/p&gt;
&lt;p&gt;先左再中最后右&lt;/p&gt;
&lt;h3&gt;递归：分治法&lt;/h3&gt;
&lt;p&gt;运用分治法，这是大多数树问题均可使用的办法&lt;/p&gt;
&lt;p&gt;分为左子树和右子树，不断地减小问题的规模&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;version 1：Non-recursion（recommended）
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List&amp;lt;Integer&amp;gt; inorderTraversal(TreeNode root) {
        Stack&amp;lt;TreeNode&amp;gt; stack = new Stack&amp;lt;TreeNode&amp;gt;();
        List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;Integer&amp;gt;();
        TreeNode cur = root;
        while (cur != null || !stack.empty()){
            while(cur != null){
                stack.push(cur);
                cur = cur.left;
            }
            cur = stack.pop();
            result.add(cur.val);
            cur = cur.right;

        }
        return result;
    }
}

version 2：Traversal
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List&amp;lt;Integer&amp;gt; inorderTraversal(TreeNode root) {
        List&amp;lt;Integer&amp;gt; inorderTraversal = new ArrayList&amp;lt;Integer&amp;gt;();
        traversal(root,inorderTraversal);
        return inorderTraversal;
    }
    private void traversal(TreeNode root,List&amp;lt;Integer&amp;gt; result){
        if (root == null){
            return;
        }

        traversal(root.left,result);
        result.add(root.val);
        traversal(root.right,result);

    }
}

version 3：Divide &amp;amp; Conquer
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List&amp;lt;Integer&amp;gt; inorderTraversal(TreeNode root) {
        List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;Integer&amp;gt;();
        if (root == null){
            return result;
        }
        //Divide &amp;amp; Conquer

        //Divide
        List&amp;lt;Integer&amp;gt; left = inorderTraversal(root.left);
        List&amp;lt;Integer&amp;gt; right = inorderTraversal(root.right);
        //Conquer
        result.addAll(left);
        result.add(root.val);
        result.addAll(right);

        return result;
    }
}
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Binary Tree"></category></entry><entry><title>Leetcode@Binary Tree Preorder Traversal</title><link href="http://www.zhangge208.com/pages/2015/12/15/leetcodebinary-tree-preorder-traversal.html" rel="alternate"></link><updated>2015-12-15T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-12-15:pages/2015/12/15/leetcodebinary-tree-preorder-traversal.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Leetcode@Binary Tree Preorder Traversal&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Given a binary tree, return the preorder traversal of its nodes' values.&lt;/p&gt;
&lt;p&gt;For example:
Given binary tree {1,#,2,3},&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;　　1
 　　\
  　　2
 　　/
　　3
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;return [1,2,3].&lt;/p&gt;
&lt;p&gt;Note: Recursive solution is trivial, could you do it iteratively?&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;三种做法：1.非递归（推荐） 2.递归：遍历 3.递归：分治法&lt;/p&gt;
&lt;h3&gt;非递归&lt;/h3&gt;
&lt;p&gt;运用栈和迭代。值得注意的是，左右节点入栈的先后顺序，栈是先入后出的数据结构，为保证是前序遍历，所以右节点先入栈，然后左节点。&lt;/p&gt;
&lt;h3&gt;递归：遍历&lt;/h3&gt;
&lt;p&gt;运用遍历的方法&lt;/p&gt;
&lt;p&gt;先根再左最后右&lt;/p&gt;
&lt;h3&gt;递归：分治法&lt;/h3&gt;
&lt;p&gt;运用分治法，这是大多数树问题均可使用的办法&lt;/p&gt;
&lt;p&gt;分为左子树和右子树，不断地减小问题的规模&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;值得注意：&lt;/strong&gt;
(1)容器中addAll方法的使用，把一个容器中的所有元素加入到另一个容器的后面。&lt;/p&gt;
&lt;p&gt;(2)记得对于边界条件的处理、异常处理。&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;version 1：Non-recurison
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List&amp;lt;Integer&amp;gt; preorderTraversal(TreeNode root) {
        Stack&amp;lt;TreeNode&amp;gt; stack = new Stack&amp;lt;TreeNode&amp;gt;();
        List&amp;lt;Integer&amp;gt; preorder = new ArrayList&amp;lt;Integer&amp;gt;();

        if (root == null){
            return preorder;
        }

        stack.push(root);

        while (!stack.empty()){
            TreeNode node = stack.pop();
            preorder.add(node.val);

            if (node.right != null){
                stack.push(node.right);
            }
            if (node.left != null){
                stack.push(node.left);
            }
        }
        return preorder;
    }
}

version 2：Traverse
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List&amp;lt;Integer&amp;gt; preorderTraversal(TreeNode root) {
        ArrayList&amp;lt;Integer&amp;gt; preorder = new ArrayList&amp;lt;Integer&amp;gt;();
        traverse(root,preorder);
        return preorder;
    }
    private void traverse(TreeNode root, ArrayList&amp;lt;Integer&amp;gt;preorder){
        if (root == null){
            return ;
        }

        preorder.add(root.val);
        traverse(root.left,preorder);
        traverse(root.right, preorder);

    }
}

version 3：Divide &amp;amp; Conquer
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List&amp;lt;Integer&amp;gt; preorderTraversal(TreeNode root) {
        ArrayList&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;Integer&amp;gt;();
        if (root == null){
            return result;
        }
        //Divide &amp;amp; Conquer

        //Divide
        ArrayList&amp;lt;Integer&amp;gt; left = preorderTraversal(root.left);
        ArrayList&amp;lt;Integer&amp;gt; right = preorderTraversal(root.right);

        //Conquer
        result.add(root.val);
        result.addAll(left);
        result.addAll(right);
        return result;
    }
}
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Binary Tree"></category></entry><entry><title>Permutation Sequence</title><link href="http://www.zhangge208.com/pages/2015/11/02/permutation-sequence.html" rel="alternate"></link><updated>2015-11-02T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-11-02:pages/2015/11/02/permutation-sequence.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Permutation Sequence&lt;/h1&gt;
&lt;h2&gt;Problem&lt;/h2&gt;
&lt;p&gt;The set &lt;code&gt;[1,2,3,…,n]&lt;/code&gt; contains a total of n! unique permutations.&lt;/p&gt;
&lt;p&gt;By listing and labeling all of the permutations in order,
We get the following sequence (ie, for n = 3):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;"123"&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;"132"&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;"213"&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;"231"&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;"312"&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;"321"&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Given n and k, return the kth permutation sequence.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Given n will be between 1 and 9 inclusive.&lt;/p&gt;
&lt;h2&gt;Code&lt;/h2&gt;
&lt;p&gt;public class Solution {
    public String getPermutation(int n, int k) {
        List&lt;Integer&gt; nums = new ArrayList&lt;Integer&gt;();
        if (n == 0){
            return "";
        }
        for(int i = 0; i &amp;lt;= n; i++){
            nums.add(i);
        }
        String res = "";&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    int factorial;
    int index;

    for (int i = n;i &amp;gt; 0;i--){
        factorial = nFatorial(i - 1);
        index = (int) Math.ceil(k / (double) factorial);

        k = k % factorial;

        res += nums.get(index);
        nums.remove(index);
        if (k == 0){
            k = factorial;
        }
    }
    return res;

}
 public int nFatorial(int n ) {
    if(n == 0){
        return 1;
    }
    return n * nFatorial(n - 1);
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}&lt;/p&gt;</summary><category term="Algorithm Backtracking"></category></entry><entry><title>Roman to Integer</title><link href="http://www.zhangge208.com/pages/2015/10/29/roman-to-integer.html" rel="alternate"></link><updated>2015-10-29T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-10-29:pages/2015/10/29/roman-to-integer.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Roman to Integer&lt;/h1&gt;
&lt;h2&gt;Problem&lt;/h2&gt;
&lt;p&gt;Given a roman numeral, convert it to an integer.&lt;/p&gt;
&lt;p&gt;Input is guaranteed to be within the range from 1 to 3999.&lt;/p&gt;
&lt;h2&gt;Code&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public int romanToInt(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }
        Map&amp;lt;Character, Integer&amp;gt; map = new HashMap&amp;lt;Character, Integer&amp;gt;();
        map.put(&amp;#39;I&amp;#39;,1);
        map.put(&amp;#39;V&amp;#39;,5);
        map.put(&amp;#39;X&amp;#39;,10);
        map.put(&amp;#39;L&amp;#39;,50);
        map.put(&amp;#39;C&amp;#39;,100);
        map.put(&amp;#39;D&amp;#39;,500);
        map.put(&amp;#39;M&amp;#39;,1000);
        int result = map.get(s.charAt(s.length() - 1)) ;
        for (int i = s.length() - 1; i &amp;gt;= 1 ; i--) {
            if (map.get(s.charAt(i - 1)) &amp;gt;= map.get(s.charAt(i))) {
                result += map.get(s.charAt(i - 1));
            }
            else {
                result -= map.get(s.charAt(i - 1));
            }

        }
        return result;
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Solution and Analysis&lt;/h2&gt;
&lt;p&gt;It`s boring so long as you know the rule that how to convert roman numeral to an integer.&lt;/p&gt;
&lt;p&gt;The base:&lt;/p&gt;
&lt;p&gt;I = 1&lt;/p&gt;
&lt;p&gt;V = 5&lt;/p&gt;
&lt;p&gt;X = 10&lt;/p&gt;
&lt;p&gt;L = 50&lt;/p&gt;
&lt;p&gt;C = 100&lt;/p&gt;
&lt;p&gt;D = 500&lt;/p&gt;
&lt;p&gt;M = 1000&lt;/p&gt;
&lt;p&gt;So we need create a map to store key-value&lt;Character, Integer&gt;.&lt;/p&gt;
&lt;p&gt;Rule:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;If a lower value symbol is before a higher value one, it is subtracted. Otherwise it is added &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Order: Right to left&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Algorithm String"></category></entry><entry><title>String to Integer (atoi)</title><link href="http://www.zhangge208.com/pages/2015/10/29/string-to-integer-atoi.html" rel="alternate"></link><updated>2015-10-29T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-10-29:pages/2015/10/29/string-to-integer-atoi.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;String to Integer (atoi)&lt;/h1&gt;
&lt;h2&gt;Problem&lt;/h2&gt;
&lt;p&gt;Implement atoi to convert a string to an integer.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hint:&lt;/strong&gt; Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Notes:&lt;/strong&gt; It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.&lt;/p&gt;
&lt;h2&gt;Code&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public int myAtoi(String str) {
        if (str == null || str.length() == 0) {
            return 0;
        }
        str = str.trim();
        int sign = 1;
        int index = 0;

        if (str.charAt(index) == &amp;#39;+&amp;#39;) {
            index++;
        }
        else if (str.charAt(index) == &amp;#39;-&amp;#39;) {
            sign = -1;
            index++;
        }
        long  num = 0;

        for(int i = index; i &amp;lt; str.length(); i++) {
            if (str.charAt(i) &amp;lt; &amp;#39;0&amp;#39; || str.charAt(i) &amp;gt; &amp;#39;9&amp;#39;)
                break;
            num = num * 10 + str.charAt(i) - &amp;#39;0&amp;#39;;

            if (num &amp;gt; Integer.MAX_VALUE) {
                break;
            }
        }

        if (num * sign &amp;lt; Integer.MIN_VALUE) {
            return  Integer.MIN_VALUE;
        }    
        if (num * sign &amp;gt; Integer.MAX_VALUE) {
            return Integer.MAX_VALUE;
        }

        return (int) num * sign;
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Solution and Analysis&lt;/h2&gt;
&lt;p&gt;There are some points we should focus as below：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The function first discards as many whitespace characters as necessary until the first non-whitespace character is found.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Algorithm String"></category></entry><entry><title>Combinations</title><link href="http://www.zhangge208.com/pages/2015/10/19/combinations.html" rel="alternate"></link><updated>2015-10-19T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-10-19:pages/2015/10/19/combinations.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Combinations&lt;/h1&gt;
&lt;h2&gt;Problem&lt;/h2&gt;
&lt;p&gt;Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.&lt;/p&gt;
&lt;p&gt;For example,
If n = 4 and k = 2, a solution is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Code&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combine(int n, int k) {
        if (n == 0 || k == 0) {
            return null;
        }
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();
        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();
        helper(result, list, n, k, 1);
        return result;
    }

    private void helper(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result, List&amp;lt;Integer&amp;gt; list, int n, int k, int start) {
        if (list.size() == k) {
            result.add(new ArrayList&amp;lt;Integer&amp;gt;(list));
            return;
        }

        for (int i = start; i &amp;lt;= n; i++) {
            list.add(i);
            helper(result, list, n, k, i + 1);
            list.remove(list.size() - 1);
        }

    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Solution and Analysis&lt;/h2&gt;
&lt;p&gt;The solution is standard, the main part of code is same as subsets template.&lt;/p&gt;
&lt;p&gt;Noticing the condidtion that list is added to result.&lt;/p&gt;</summary><category term="Algorithm Backtracking"></category></entry><entry><title>Palindrome Partitioning</title><link href="http://www.zhangge208.com/pages/2015/10/19/palindrome-partitioning.html" rel="alternate"></link><updated>2015-10-19T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-10-19:pages/2015/10/19/palindrome-partitioning.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Palindrome Partitioning&lt;/h1&gt;
&lt;h2&gt;Problem&lt;/h2&gt;
&lt;p&gt;Given a string s, partition s such that every substring of the partition is a palindrome.&lt;/p&gt;
&lt;p&gt;Return all possible palindrome partitioning of s.&lt;/p&gt;
&lt;p&gt;For example, given s = &lt;code&gt;"aab"&lt;/code&gt;,&lt;/p&gt;
&lt;p&gt;Return&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;[
    [&amp;quot;aa&amp;quot;,&amp;quot;b&amp;quot;],
    [&amp;quot;a&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;]
]
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Code&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; partition(String s) {
        List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; result = new ArrayList&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;();
        List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();
        helper(result, list, s, 0);
        return result;
    }

    private void helper(List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; result, List&amp;lt;String&amp;gt; list, String str, int pos) {
        if (pos == str.length()) {
            result.add(new ArrayList&amp;lt;String&amp;gt;(list));
            return;
        }

        for (int i = pos; i &amp;lt; str.length(); i++) {
            String sub = str.substring(pos, i + 1);
            if (isPartition(sub)) {
                list.add(sub);
                helper(result, list, str, i + 1);
                list.remove(list.size() - 1);
            }
        }
    }

    private boolean isPartition(String str) {
        int left = 0, right = str.length() - 1;
        while (left &amp;lt; right) {
            if (str.charAt(left) != str.charAt(right)) 
                return false;
            left++;
            right--;
        }
        return true;
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Solution and Analysis&lt;/h2&gt;</summary><category term="Algorithm Backtracking"></category></entry><entry><title>Backtracking</title><link href="http://www.zhangge208.com/pages/2015/10/13/backtracking.html" rel="alternate"></link><updated>2015-10-13T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-10-13:pages/2015/10/13/backtracking.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Backtracking&lt;/h1&gt;
&lt;h2&gt;Concept &amp;amp;&amp;amp; Idea&lt;/h2&gt;
&lt;h3&gt;Concept&lt;/h3&gt;
&lt;p&gt;回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。&lt;/p&gt;
&lt;h3&gt;Idea&lt;/h3&gt;
&lt;p&gt;在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。&lt;/p&gt;
&lt;p&gt;若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。&lt;/p&gt;
&lt;p&gt;而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。&lt;/p&gt;
&lt;h2&gt;Step &amp;amp;&amp;amp; Template&lt;/h2&gt;
&lt;h3&gt;Step&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;针对所给问题，确定问题的解空间：首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。&lt;/li&gt;
&lt;li&gt;确定结点的扩展搜索规则&lt;/li&gt;
&lt;li&gt;以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Template&lt;/h3&gt;
&lt;p&gt;以&lt;a href="https://leetcode.com/problems/subsets/"&gt;Subsets&lt;/a&gt;为例，给出Backtracking Template&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsets(int[] nums) {
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();
        if (nums == null || nums.length == 0){
            return result;
        }
        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();
        Arrays.sort(nums);
        subsetHelp(result, list, nums, 0);
        return result;
    }

    private void subsetHelp(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result, List&amp;lt;Integer&amp;gt;list, int[] nums, int pos){
        result.add(new ArrayList&amp;lt;Integer&amp;gt;(list));

        for (int i = pos; i &amp;lt; nums.length; i++){
            list.add(nums[i]);
            subsetHelp(result, list, nums, i + 1);
            list.remove(list.size() - 1);

        }
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;Note：&lt;/strong&gt;很多题目的解法均是在这个模板的基础上，但剪枝的条件会有所不同&lt;/p&gt;
&lt;h2&gt;Problem List&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.zhangge208.com/pages/2015/10/13/subsets.html"&gt;Subsets&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhangge208.com/pages/2015/10/13/subsets-ii.html"&gt;Subsets II&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhangge208.com/pages/2015/10/13/permutations.html"&gt;Permutations&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhangge208.com/pages/2015/10/13/permutations-ii.html"&gt;Permutations II&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhangge208.com/pages/2015/10/19/combinations.html"&gt;Combinations&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhangge208.com/pages/2015/10/13/combination-sum.html"&gt;Combination Sum&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhangge208.com/pages/2015/10/13/combination-sum-ii.html"&gt;Combination Sum II&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhangge208.com/pages/2015/10/13/combination-sum-iii.html"&gt;Combination Sum III&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhangge208.com/pages/2015/10/19/palindrome-partitioning.html"&gt;Palindrome Partitioning&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=""&gt;Palindrome Partitioning II&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=""&gt;Restore IP Addresses&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Letter Combinations of a Phone Number&lt;/p&gt;</summary><category term="Algorithm Backtracking"></category></entry><entry><title>Combination Sum</title><link href="http://www.zhangge208.com/pages/2015/10/13/combination-sum.html" rel="alternate"></link><updated>2015-10-13T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-10-13:pages/2015/10/13/combination-sum.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Combination Sum&lt;/h1&gt;
&lt;h2&gt;Problem&lt;/h2&gt;
&lt;p&gt;Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;same&lt;/strong&gt; repeated number may be chosen from C unlimited number of times.&lt;/p&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All numbers (including target) will be positive integers.&lt;/li&gt;
&lt;li&gt;Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).&lt;/li&gt;
&lt;li&gt;The solution set must not contain duplicate combinations.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For example, given candidate set &lt;code&gt;2,3,6,7&lt;/code&gt; and target &lt;code&gt;7&lt;/code&gt;, 
A solution set is: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;[7]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[2, 2, 3]&lt;/code&gt; &lt;/p&gt;
&lt;h2&gt;Code&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum(int[] candidates, int target) {
        if (candidates.length == 0 || candidates == null) {
            return null;
        } 
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();
        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();
        Arrays.sort(candidates);
        helper(result, list,candidates, target, 0);
        return result;
    }

    private void helper(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result,List&amp;lt;Integer&amp;gt; list, int[] candidates, int target, int pos ) {
        if (target == 0) {
            result.add(new ArrayList&amp;lt;Integer&amp;gt;(list));
            return;
        }
        else if (target &amp;lt; 0) {
            return;
        }

        for(int i = pos; i &amp;lt; candidates.length; i++) {
            list.add(candidates[i]);
            helper(result, list, candidates, target - candidates[i],i);
            list.remove(list.size() - 1);
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Solution and Analysis&lt;/h2&gt;
&lt;p&gt;subsets template，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;must:&lt;/p&gt;
&lt;p&gt;else if (target &amp;lt; 0) {
            return;
        }
in order to avoid stackoverflow&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;helper(result, list, candidates, target - candidates[i],&lt;strong&gt;i&lt;/strong&gt;);
  这里为什么是i而不是i + 1，因为题目中说C中的元素可以重复取无限次，那么如果写为i + 1的话，这个元素将不能再次被取到&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Arrays.sort(candidates);Sort array first!&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary><category term="Algorithm Backtracking"></category></entry><entry><title>Combination Sum II</title><link href="http://www.zhangge208.com/pages/2015/10/13/combination-sum-ii.html" rel="alternate"></link><updated>2015-10-13T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-10-13:pages/2015/10/13/combination-sum-ii.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Combination Sum II&lt;/h1&gt;
&lt;h2&gt;Problem&lt;/h2&gt;
&lt;p&gt;Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.&lt;/p&gt;
&lt;p&gt;Each number in C may only be used once in the combination.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All numbers (including target) will be positive integers.&lt;/li&gt;
&lt;li&gt;Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).&lt;/li&gt;
&lt;li&gt;The solution set must not contain duplicate combinations.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For example, given candidate set &lt;code&gt;10,1,2,7,6,1,5&lt;/code&gt; and target &lt;code&gt;8&lt;/code&gt;, 
A solution set is: 
&lt;code&gt;[1, 7]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[1, 2, 5]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[2, 6]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[1, 1, 6]&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Code&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum2(int[] candidates, int target) {
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();
        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();
        Arrays.sort(candidates);
        helper(result, list,candidates, target, 0);
        return result;
    }
    private void helper(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result, List&amp;lt;Integer&amp;gt; list, int[] candidates, int target, int pos) {
        if (target == 0) {
            result.add(new ArrayList&amp;lt;Integer&amp;gt;(list));
            return;
        }
        else if (target &amp;lt; 0) {
            return;
        }

        for (int i = pos; i &amp;lt; candidates.length; i++) {
            if (i &amp;gt; pos &amp;amp;&amp;amp; candidates[i] == candidates[i - 1]) {
                continue;
            }
            list.add(candidates[i]);
            helper(result, list, candidates, target - candidates[i], i + 1);
            list.remove(list.size() - 1);
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Solution and Analysis&lt;/h2&gt;
&lt;p&gt;reference: &lt;a href="http://www.shuatiblog.com/blog/2014/05/13/Combination-Sum-II/"&gt;http://www.shuatiblog.com/blog/2014/05/13/Combination-Sum-II/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;the main part of is same as “Combination Sum”&lt;/strong&gt;,there is only some code that needs to be modified.&lt;/p&gt;
&lt;p&gt;Considering Each number in C may only be used once in the combination. When going into the next recursive call, instead of:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;helper(result, list, candidates, target - candidates[i], i);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Change it to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;helper(result, list, candidates, target - candidates[i], i + 1);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In addition,we take over this test case:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;[1,1] 1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;in order to ensure that the solution set must not contain duplicate combinations, instead of getting next element right away, we get the element with different value.&lt;/p&gt;
&lt;p&gt;add some code as below:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;if (i &amp;gt; pos &amp;amp;&amp;amp; candidates[i] == candidates[i - 1]) {
                continue;
}
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Backtracking"></category></entry><entry><title>Combination Sum III</title><link href="http://www.zhangge208.com/pages/2015/10/13/combination-sum-iii.html" rel="alternate"></link><updated>2015-10-13T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-10-13:pages/2015/10/13/combination-sum-iii.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Combination Sum III&lt;/h1&gt;
&lt;h2&gt;Problem&lt;/h2&gt;
&lt;p&gt;Find all possible combinations of &lt;strong&gt;k&lt;/strong&gt; numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.&lt;/p&gt;
&lt;p&gt;Ensure that numbers within the set are sorted in ascending order.&lt;/p&gt;
&lt;h2&gt;Code&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; combinationSum3(int k, int n) {
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();
        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();
        int[] nums = new int[9];
        for (int i = 1; i &amp;lt;= 9; i++) {
            nums[i - 1] = i;
        }
        helper(result, list, nums, k, n, 0);
        return result;
    }
    private void helper(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result, List&amp;lt;Integer&amp;gt; list, int[] nums, int size, int target, int pos) {
        if (list.size() == size &amp;amp;&amp;amp; target == 0) {
            result.add(new ArrayList&amp;lt;Integer&amp;gt;(list));
            return;
        }
        else if (target &amp;lt; 0) {
            return;
        }
        for (int i = pos; i &amp;lt; nums.length; i++) {
            list.add(nums[i]);
            helper(result, list, nums, size, target - nums[i], i + 1);
            list.remove(list.size() - 1);
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Solution and Analysis&lt;/h2&gt;</summary><category term="Algorithm Backtracking"></category></entry><entry><title>Permutations</title><link href="http://www.zhangge208.com/pages/2015/10/13/permutations.html" rel="alternate"></link><updated>2015-10-13T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-10-13:pages/2015/10/13/permutations.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Permutations&lt;/h1&gt;
&lt;h2&gt;Problem&lt;/h2&gt;
&lt;p&gt;Given a collection of numbers, return all possible permutations.&lt;/p&gt;
&lt;p&gt;For example,
&lt;code&gt;[1,2,3]&lt;/code&gt; have the following permutations:
&lt;code&gt;[1,2,3]&lt;/code&gt;, &lt;code&gt;[1,3,2]&lt;/code&gt;, &lt;code&gt;[2,1,3]&lt;/code&gt;, &lt;code&gt;[2,3,1]&lt;/code&gt;, &lt;code&gt;[3,1,2]&lt;/code&gt;, and &lt;code&gt;[3,2,1]&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Code&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permute(int[] nums) {
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();
        if (nums == null &amp;amp;&amp;amp; nums.length == 0){
            return result;
        }

        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();
        permuteHelper(result, list, nums);
        return result;
    }
    private void permuteHelper(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result, List&amp;lt;Integer&amp;gt; list, int[] nums){
        if (list.size() == nums.length) {
            result.add(new ArrayList&amp;lt;Integer&amp;gt;(list));
        }

        for(int i = 0; i &amp;lt; nums.length; i++) {
            if (list.contains(nums[i])) {
                continue;
            }
            list.add(nums[i]);
            permuteHelper(result, list, nums);
            list.remove(list.size() - 1);
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Solution and Analysis&lt;/h2&gt;
&lt;p&gt;The main part of code is same as the subset template,recursively add elements into a list, until all elements are added.Make sure that the list do not contain the current element.&lt;/p&gt;
&lt;p&gt;Note:This type of permutation questions always requires add/remove before/after a recursion.&lt;/p&gt;</summary><category term="Algorithm Backtracking"></category></entry><entry><title>Permutations II</title><link href="http://www.zhangge208.com/pages/2015/10/13/permutations-ii.html" rel="alternate"></link><updated>2015-10-13T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-10-13:pages/2015/10/13/permutations-ii.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Permutations II&lt;/h1&gt;
&lt;h2&gt;Problem&lt;/h2&gt;
&lt;p&gt;Given a collection of numbers that might contain duplicates, return all possible unique permutations.&lt;/p&gt;
&lt;p&gt;For example,&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[1,1,2]&lt;/code&gt; have the following unique permutations:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[1,1,2]&lt;/code&gt;,&lt;code&gt;[1,2,1]&lt;/code&gt;, and &lt;code&gt;[2,1,1]&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Code&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permuteUnique(int[] nums) {
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();

        if (nums == null || nums.length == 0){
            return result;
        }

        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();
        int[] visited = new int[nums.length];
        Arrays.sort(nums);
        permuteHelper(result, list,visited, nums);
        return result; 
    }
    public void permuteHelper( List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result, List&amp;lt;Integer&amp;gt; list,int[] visited, int[] nums){

        if (list.size() == nums.length){
            result.add(new ArrayList(list));
            return;
        }
        for (int i = 0; i &amp;lt; nums.length; i++){
            if (visited[i] == 1 ||(i != 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1] &amp;amp;&amp;amp; visited[i - 1] == 0)){
                continue;
            }
            visited[i] = 1;
            list.add(nums[i]);
            permuteHelper(result, list,visited, nums);
            list.remove(list.size() - 1);
            visited[i] = 0;
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Solution and Analysis&lt;/h2&gt;
&lt;p&gt;This question is based on Permutations, plus duplication avoidance.&lt;/p&gt;
&lt;p&gt;The idea is when getting element from remaining list and add to current list, check for duplication. If the number occured before, skip operation. (Don’t forget sorting is required at first).&lt;/p&gt;
&lt;p&gt;The key points to keep in mind:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Use another array to flag the ‘visited’ items&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Check items with same value, and &lt;strong&gt;ONLY USE THE FIRST INSTANCE OF THE SAME VALUE&lt;/strong&gt;. Which is to say, if current = previous, but previous is not visited, do not use current number.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Algorithm Backtracking"></category></entry><entry><title>Subsets</title><link href="http://www.zhangge208.com/pages/2015/10/13/subsets.html" rel="alternate"></link><updated>2015-10-13T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-10-13:pages/2015/10/13/subsets.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Subsets&lt;/h1&gt;
&lt;h2&gt;Problem&lt;/h2&gt;
&lt;p&gt;Given a set of distinct integers, nums, return all possible subsets.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;
- Elements in a subset must be in non-descending order.
- The solution set must not contain duplicate subsets.&lt;/p&gt;
&lt;p&gt;For example,&lt;/p&gt;
&lt;p&gt;If &lt;strong&gt;nums&lt;/strong&gt; = &lt;code&gt;[1,2,3]&lt;/code&gt;, a solution is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Code&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsets(int[] nums) {
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();
        if (nums == null || nums.length == 0){
            return result;
        }
        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();
        Arrays.sort(nums);
        subsetHelp(result, list, nums, 0);
        return result;
    }

    private void subsetHelp(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result, List&amp;lt;Integer&amp;gt;list, int[] nums, int pos){
        result.add(new ArrayList&amp;lt;Integer&amp;gt;(list));

        for (int i = pos; i &amp;lt; nums.length; i++){
            list.add(nums[i]);
            subsetHelp(result, list, nums, i + 1);
            list.remove(list.size() - 1);

        } 
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Solution and Analysis&lt;/h2&gt;
&lt;p&gt;reference: &lt;a href="http://algorithm.yuanbin.me"&gt;http://algorithm.yuanbin.me&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;backtracking可用图示与函数运行的堆栈来理解，以[1, 2, 3]为例，下图为list及result的变化过程，箭头向下表示list.add及result.add操作，箭头向上表示list.remove操作&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://7xltae.com1.z0.glb.clouddn.com/subset.jpg" /&gt; &lt;br /&gt;
&lt;/p&gt;</summary><category term="Algorithm Backtracking"></category></entry><entry><title>Subsets II</title><link href="http://www.zhangge208.com/pages/2015/10/13/subsets-ii.html" rel="alternate"></link><updated>2015-10-13T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-10-13:pages/2015/10/13/subsets-ii.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Subsets II#&lt;/h1&gt;
&lt;h2&gt;Problem&lt;/h2&gt;
&lt;p&gt;Given a collection of integers that might contain duplicates, nums, return all possible subsets.&lt;/p&gt;
&lt;p&gt;Note:
- Elements in a subset must be in non-descending order.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The solution set must not contain duplicate subsets.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For example,&lt;/p&gt;
&lt;p&gt;If &lt;strong&gt;nums&lt;/strong&gt; = &lt;code&gt;[1,2,2]&lt;/code&gt;, a solution is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Code&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; subsetsWithDup(int[] nums) {
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();

        if (nums == null || nums.length == 0) {
            return result;
        }

        Arrays.sort(nums);
        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();
        helper(result, list, nums, 0);
        return result;
    }
    private void helper(List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result, List&amp;lt;Integer&amp;gt; list, int[] nums, int pos) {
        result.add(new ArrayList&amp;lt;Integer&amp;gt;(list));
        for (int i = pos; i &amp;lt; nums.length; i++) {
            if ( i != pos &amp;amp;&amp;amp; nums[i] == nums[i - 1]) {
                continue;
            }
            list.add(nums[i]);
            helper(result, list, nums, i + 1);
            list.remove(list.size() - 1);
        }

    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Solution and Analysis&lt;/h2&gt;
&lt;p&gt;The main part of code is same as the subset template，&lt;/p&gt;
&lt;p&gt;For example，input = {1，2(1)，2(2)，2(3)}&lt;/p&gt;
&lt;p&gt;Initialize the subset: {}&lt;/p&gt;
&lt;p&gt;Added element “1”: {}, &lt;strong&gt;{1}&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;Added element “2”: {}, {1}, &lt;strong&gt;{2(1)}&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;{1, 2(1)}, {1, 2(2)} are duplicate subset, {1,2(1),2(2)}, {1,2(2),2(3)} are iterant, too. &lt;/p&gt;
&lt;p&gt;We arrive ar a conclusion:we are only concerned with getting how many '2' rather than get which '2'&lt;br /&gt;
&lt;/p&gt;</summary><category term="Algorithm Backtracking"></category></entry><entry><title>Binary Search</title><link href="http://www.zhangge208.com/pages/2015/09/09/binary-search.html" rel="alternate"></link><updated>2015-09-09T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-09-09:pages/2015/09/09/binary-search.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Binary Search&lt;/h1&gt;
&lt;h2&gt;基础模板&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.lintcode.com/zh-cn/problem/binary-search/"&gt;Binary Search&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;先给一个错误的示例，原来一直这样写，但在有重复元素时无法适用&lt;/p&gt;
&lt;p&gt;错误示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Solution&lt;/span&gt; {
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;binarySearch&lt;/span&gt;(&lt;span class="nb"&gt;int&lt;/span&gt;[] &lt;span class="n"&gt;nums&lt;/span&gt;, &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;target&lt;/span&gt;) {
        &lt;span class="k"&gt;if&lt;/span&gt; (&lt;span class="n"&gt;nums&lt;/span&gt; == &lt;span class="n"&gt;null&lt;/span&gt; || &lt;span class="n"&gt;nums&lt;/span&gt;.&lt;span class="n"&gt;length&lt;/span&gt; == &lt;span class="mi"&gt;0&lt;/span&gt;) {
            &lt;span class="k"&gt;return&lt;/span&gt; -&lt;span class="mi"&gt;1&lt;/span&gt;;
        }

        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt; = &lt;span class="mi"&gt;0&lt;/span&gt;;
        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="nb"&gt;end&lt;/span&gt; = &lt;span class="n"&gt;nums&lt;/span&gt;.&lt;span class="n"&gt;length&lt;/span&gt; - &lt;span class="mi"&gt;1&lt;/span&gt;;

        &lt;span class="k"&gt;while&lt;/span&gt; (&lt;span class="n"&gt;start&lt;/span&gt; &amp;lt;= &lt;span class="nb"&gt;end&lt;/span&gt;) {
            &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt; = &lt;span class="n"&gt;start&lt;/span&gt; + (&lt;span class="nb"&gt;end&lt;/span&gt; - &lt;span class="n"&gt;start&lt;/span&gt;) / &lt;span class="mi"&gt;2&lt;/span&gt;;
            &lt;span class="k"&gt;if&lt;/span&gt; (&lt;span class="n"&gt;nums&lt;/span&gt;[&lt;span class="n"&gt;mid&lt;/span&gt;] == &lt;span class="n"&gt;target&lt;/span&gt;) {
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt;;
            }
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; (&lt;span class="n"&gt;nums&lt;/span&gt;[&lt;span class="n"&gt;mid&lt;/span&gt;] &amp;lt; &lt;span class="n"&gt;target&lt;/span&gt;) {
                &lt;span class="n"&gt;start&lt;/span&gt; = &lt;span class="n"&gt;mid&lt;/span&gt;;
            }
            &lt;span class="k"&gt;else&lt;/span&gt; {
                &lt;span class="nb"&gt;end&lt;/span&gt; = &lt;span class="n"&gt;mid&lt;/span&gt;;
            }
        } 
        &lt;span class="k"&gt;return&lt;/span&gt; -&lt;span class="mi"&gt;1&lt;/span&gt;;
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;考虑下面的测试用例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;input：
[3,4,5,8,8,8,8,10,13,14], 8
output：
4
expect：
3
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在有重复元素时会出现问题&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.jiuzhang.com/solutions/binary-search/"&gt;Binary Search模板（参考九章算法）&lt;/a&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Solution&lt;/span&gt; {
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;binarySearch&lt;/span&gt;(&lt;span class="nb"&gt;int&lt;/span&gt;[] &lt;span class="n"&gt;nums&lt;/span&gt;, &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;target&lt;/span&gt;) {
        &lt;span class="k"&gt;if&lt;/span&gt; (&lt;span class="n"&gt;nums&lt;/span&gt; == &lt;span class="n"&gt;null&lt;/span&gt; || &lt;span class="n"&gt;nums&lt;/span&gt;.&lt;span class="n"&gt;length&lt;/span&gt; == &lt;span class="mi"&gt;0&lt;/span&gt;) {
            &lt;span class="k"&gt;return&lt;/span&gt; -&lt;span class="mi"&gt;1&lt;/span&gt;;
        }

        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt; = &lt;span class="mi"&gt;0&lt;/span&gt;;
        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="nb"&gt;end&lt;/span&gt; = &lt;span class="n"&gt;nums&lt;/span&gt;.&lt;span class="n"&gt;length&lt;/span&gt; - &lt;span class="mi"&gt;1&lt;/span&gt;;

        &lt;span class="k"&gt;while&lt;/span&gt; (&lt;span class="n"&gt;start&lt;/span&gt; + &lt;span class="mi"&gt;1&lt;/span&gt; &amp;lt; &lt;span class="nb"&gt;end&lt;/span&gt;) {
            &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt; = &lt;span class="n"&gt;start&lt;/span&gt; + (&lt;span class="nb"&gt;end&lt;/span&gt; - &lt;span class="n"&gt;start&lt;/span&gt;) / &lt;span class="mi"&gt;2&lt;/span&gt;;
            &lt;span class="k"&gt;if&lt;/span&gt; (&lt;span class="n"&gt;target&lt;/span&gt; &amp;lt; &lt;span class="n"&gt;nums&lt;/span&gt;[&lt;span class="n"&gt;mid&lt;/span&gt;]) {
                &lt;span class="nb"&gt;end&lt;/span&gt; = &lt;span class="n"&gt;mid&lt;/span&gt;;
            }
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; (&lt;span class="n"&gt;target&lt;/span&gt; &amp;gt; &lt;span class="n"&gt;nums&lt;/span&gt;[&lt;span class="n"&gt;mid&lt;/span&gt;]) {
                &lt;span class="n"&gt;start&lt;/span&gt; = &lt;span class="n"&gt;mid&lt;/span&gt;;
            }
            &lt;span class="k"&gt;else&lt;/span&gt; {
                &lt;span class="nb"&gt;end&lt;/span&gt; = &lt;span class="n"&gt;mid&lt;/span&gt;;
            }
        }

        &lt;span class="k"&gt;if&lt;/span&gt; (&lt;span class="n"&gt;nums&lt;/span&gt;[&lt;span class="n"&gt;start&lt;/span&gt;] == &lt;span class="n"&gt;target&lt;/span&gt;) {
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;;
        }
        &lt;span class="k"&gt;if&lt;/span&gt; (&lt;span class="n"&gt;nums&lt;/span&gt;[&lt;span class="nb"&gt;end&lt;/span&gt;] == &lt;span class="n"&gt;target&lt;/span&gt;) {
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;end&lt;/span&gt;;
        }

        &lt;span class="k"&gt;return&lt;/span&gt; -&lt;span class="mi"&gt;1&lt;/span&gt;;
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Keypoints：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对输入做异常处理：数组为空或者数组长度为0。&lt;/li&gt;
&lt;li&gt;int mid = start + (end - start) / 2 这种表示方法可以防止两个整型值相加时溢出。&lt;/li&gt;
&lt;li&gt;Recursion or While-Loop：使用迭代而不是递归进行二分查找，因为工程中递归写法存在潜在溢出的可能&lt;/li&gt;
&lt;li&gt;while循环终止条件：while终止条件应为start + 1 &amp;lt; end而不是start &amp;lt;= end，start == end时可能出现死循环，即循环终止条件是相邻或相交元素时退出。配合while终止条件start + 1 &amp;lt; end（相邻即退出）的赋值语句mid永远没有+1或者-1，这样不会死循环。&lt;/li&gt;
&lt;li&gt;迭代终止时target应为start或者end中的一个。循环终止条件有两个，具体应看是找第一个还是最后一个而定。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Problem List&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.zhangge208.com/pages/2015/09/09/search-insert-position.html"&gt;Search Insert Position&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhangge208.com/pages/2015/09/09/search-for-a-range.html"&gt;Search for a Range&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhangge208.com/pages/2015/09/09/search-in-rotated-sorted-array.html"&gt;Search in Rotated Sorted Array&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=""&gt;Search in Rotated Sorted Array II&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhangge208.com/pages/2015/09/09/search-a-2d-matrix.html"&gt;Search a 2D Matrix&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhangge208.com/pages/2015/09/09/search-a-2d-matrix-ii.html"&gt;Search a 2D Matrix II&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhangge208.com/pages/2015/09/09/first-bad-version.html"&gt;First Bad Version&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhangge208.com/pages/2015/09/09/find-peak-element.html"&gt;Find Peak Element&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhangge208.com/pages/2015/09/09/find-minimum-in-rotated-sorted-array.html"&gt;Find Minimum in Rotated Sorted Array&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=""&gt;Find Minimum in Rotated Sorted Array II&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhangge208.com/pages/2015/09/09/minimum-size-subarray-sum.html"&gt;Minimum Size Subarray Sum&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.zhangge208.com/pages/2015/09/09/h-index-ii.html"&gt;H-Index II&lt;/a&gt;&lt;/p&gt;</summary><category term="Algorithm Binary Search"></category></entry><entry><title>Find Minimum in Rotated Sorted Array</title><link href="http://www.zhangge208.com/pages/2015/09/09/find-minimum-in-rotated-sorted-array.html" rel="alternate"></link><updated>2015-09-09T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-09-09:pages/2015/09/09/find-minimum-in-rotated-sorted-array.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Find Minimum in Rotated Sorted Array&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Suppose a sorted array is rotated at some pivot unknown to you beforehand.&lt;/p&gt;
&lt;p&gt;(i.e., &lt;code&gt;0 1 2 4 5 6 7&lt;/code&gt; might become &lt;code&gt;4 5 6 7 0 1 2&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Find the minimum element.&lt;/p&gt;
&lt;p&gt;You may assume no duplicate exists in the array.&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public int findMin(int[] nums) {
        if (nums == null || nums.length == 0) {
            return -1;
        }

        int start = 0;
        int end = nums.length - 1;

        while (start + 1 &amp;lt; end) {
            int mid =start + (end - start) / 2;
            if (nums[mid] &amp;gt; nums[end]) {
                start = mid;
            }
            else {
                end = mid;
            }
        }
        return nums[start] &amp;lt; nums[end] ? nums[start] : nums[end];
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;与Search in Rotated Sorted Array很类似，但我们是需要寻找最小元素，那么最小元素的位置该如何确定？&lt;/p&gt;
&lt;p&gt;只需判断nums[mid]和nums[end]的大小，如果nums[mid] &amp;gt; nums[end]，表明前半部分有序，那么最小元素一定在后半部分，反之nums[mid] &amp;lt; nums[end]表明后半部分有序，最小元素在前半部分，依据这个核心思路，利用二分搜索模板即可。&lt;/p&gt;</summary><category term="Algorithm Binary Search"></category></entry><entry><title>Find Peak Element</title><link href="http://www.zhangge208.com/pages/2015/09/09/find-peak-element.html" rel="alternate"></link><updated>2015-09-09T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-09-09:pages/2015/09/09/find-peak-element.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Find Peak Element&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;A peak element is an element that is greater than its neighbors.&lt;/p&gt;
&lt;p&gt;Given an input array where &lt;code&gt;num[i] ≠ num[i+1]&lt;/code&gt;, find a peak element and return its index.&lt;/p&gt;
&lt;p&gt;The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.&lt;/p&gt;
&lt;p&gt;You may imagine that &lt;code&gt;num[-1] = num[n] = -∞&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example, in array &lt;code&gt;[1, 2, 3, 1]&lt;/code&gt;, 3 is a peak element and your function should return the index number 2.&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public int findPeakElement(int[] num) {
         int start = 0, end = num.length - 1;  
         while(start + 1 &amp;lt; end) {
            int mid = start + (end - start) / 2;
            if(num[mid] &amp;gt; num[mid - 1] &amp;amp;&amp;amp; num[mid] &amp;gt; num[mid + 1]) {
                end = mid;
            } 
            else if(num[mid] &amp;lt; num[mid + 1]) {
                start = mid;
            } 
            else {
                end = mid;
            }
        }
        if(num[start] &amp;lt; num[end]) {
            return end;
        } 
        else { 
            return start;
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;寻找局部的最大值，二分搜索&lt;/p&gt;
&lt;p&gt;需要对二分搜索的模板进行一下改动&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果num[i-1] &amp;lt; num[i] &amp;gt; num[i+1], 那么num[i]是峰值元素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果num[i-1] &amp;lt; num[i] &amp;lt; num[i+1], 那么num[i+1...n-1]一定包含一个峰值元素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果num[i-1] &amp;gt; num[i] &amp;gt; num[i+1], 那么num[0...i-1]一定包含一个峰值元素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果num[i-1] &amp;gt; num[i] &amp;lt; num[i+1], 那么任意一边都可能有峰值元素&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Algorithm Binary Search"></category></entry><entry><title>First Bad Version</title><link href="http://www.zhangge208.com/pages/2015/09/09/first-bad-version.html" rel="alternate"></link><updated>2015-09-09T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-09-09:pages/2015/09/09/first-bad-version.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;First Bad Version&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.&lt;/p&gt;
&lt;p&gt;Suppose you have &lt;code&gt;n&lt;/code&gt; versions &lt;code&gt;[1, 2, ..., n]&lt;/code&gt; and you want to find out the first bad one, which causes all the following ones to be bad.&lt;/p&gt;
&lt;p&gt;You are given an API &lt;code&gt;bool isBadVersion(version)&lt;/code&gt; which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* The isBadVersion API is defined in the parent class VersionControl.&lt;/span&gt;
&lt;span class="cm"&gt;      boolean isBadVersion(int version); */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

public&lt;span class="w"&gt; &lt;/span&gt;class&lt;span class="w"&gt; &lt;/span&gt;Solution&lt;span class="w"&gt; &lt;/span&gt;extends&lt;span class="w"&gt; &lt;/span&gt;VersionControl&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;public&lt;span class="w"&gt; &lt;/span&gt;int&lt;span class="w"&gt; &lt;/span&gt;firstBadVersion&lt;span class="o"&gt;(&lt;/span&gt;int&lt;span class="w"&gt; &lt;/span&gt;n&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;n&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;int&lt;span class="w"&gt; &lt;/span&gt;start&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;int&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;end&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;n&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;while&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;start&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;end&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;int&lt;span class="w"&gt; &lt;/span&gt;mid&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;start&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;end&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;start&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;isBadVersion&lt;span class="o"&gt;(&lt;/span&gt;mid&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;false&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;start&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;mid&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kr"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="kr"&gt;end&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;mid&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;isBadVersion&lt;span class="o"&gt;(&lt;/span&gt;start&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;true&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;start&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;isBadVersion&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;end&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;true&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;end&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;很基础的二分搜索，先要判断mid处的版本是否是bad version，如果不是，那么前半部分均可以不要，start = mid。套用二分法模板就好&lt;/p&gt;</summary><category term="Algorithm Binary Search"></category></entry><entry><title>H-Index II</title><link href="http://www.zhangge208.com/pages/2015/09/09/h-index-ii.html" rel="alternate"></link><updated>2015-09-09T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-09-09:pages/2015/09/09/h-index-ii.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;H-Index II&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Follow up&lt;/strong&gt; for &lt;a href="https://leetcode.com/problems/h-index/"&gt;H-Index&lt;/a&gt;: What if the &lt;code&gt;citations&lt;/code&gt; array is sorted in ascending order? Could you optimize your algorithm?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hint:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Expected runtime complexity is in O(log n) and the input is sorted.&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public int hIndex(int[] citations) {
        if (citations == null || citations.length == 0) {
            return 0;
        }

        int start = 0;
        int end = citations.length - 1;
        while (start + 1 &amp;lt; end) {
            int mid = start + (end - start) / 2;
            if (citations[mid] == citations.length - mid) {
                return citations.length - mid;
            }
            else if (citations[mid] &amp;lt; citations.length - mid) {
                start = mid;
            }
            else {
                end = mid;
            }
        }

        if (citations[start] &amp;gt;= citations.length - start) {
            return citations.length - start;
        }
        if (citations[end] &amp;gt;= citations.length - end) {
            return citations.length - end;
        }
        return 0;
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;O(log n)的复杂度，排序的数组输入，那么一定是二分搜索无疑了，但在模板上应该做什么样的改动呢？&lt;/p&gt;
&lt;p&gt;关键就在于h因子的定义：被引用次数等于或超过h的文章至少有h篇&lt;/p&gt;
&lt;p&gt;如果定义数组长度为n的话，最后h篇文章被引用次数应该等于或超过h，那么也就是说第n - h篇文章被引用次数应该等于或超过h，即：&lt;/p&gt;
&lt;p&gt;citations[n - h] &amp;gt;= h &lt;/p&gt;
&lt;p&gt;如果令mid = n - h，这样就可以使用二分搜索：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果citations[mid] == citations.length - mid，那么citations.length - mid即为h因子&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果citations[mid] &amp;lt; citations.length - mid，那么说明选择的mid太小，第n - h篇文章并不能满足等于或超过h，需要后移&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果citations[mid] &amp;gt; citations.length - mid，那么说明选择的mid太大，第n - h篇之前的文章就能满足等于或超过h，需要前移&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;边界条件：判断start、end两个特殊点哪个满足条件&lt;/p&gt;</summary><category term="Algorithm Binary Search"></category></entry><entry><title>Minimum Size Subarray Sum</title><link href="http://www.zhangge208.com/pages/2015/09/09/minimum-size-subarray-sum.html" rel="alternate"></link><updated>2015-09-09T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-09-09:pages/2015/09/09/minimum-size-subarray-sum.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Minimum Size Subarray Sum&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Given an array of &lt;strong&gt;n&lt;/strong&gt; positive integers and a positive integer &lt;strong&gt;s&lt;/strong&gt;, find the minimal length of a subarray of which the sum ≥ &lt;strong&gt;s&lt;/strong&gt;. If there isn't one, return 0 instead.&lt;/p&gt;
&lt;p&gt;For example, given the array &lt;code&gt;[2,3,1,2,4,3]&lt;/code&gt; and &lt;code&gt;s = 7&lt;/code&gt;,
the subarray &lt;code&gt;[4,3]&lt;/code&gt; has the minimal length under the problem  constraint.&lt;/p&gt;
&lt;p&gt;click to show more practice.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;More practice:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(nlogn).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Credits:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Special thanks to @Freezen for adding this problem and creating all test cases.&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public int minSubArrayLen(int s, int[] nums) {
        if (nums.length == 0 || nums == null) {
            return 0;
        }
        int[] sum = new int[nums.length];
        sum[0] = nums[0];
        for (int i = 1; i &amp;lt; nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i];
        }
        int ans = Integer.MAX_VALUE;
        int start, end, mid;
        for (int i = 0; i &amp;lt; sum.length; i++) {
            start = i;
            end = sum.length - 1;
            while (start + 1 &amp;lt; end) {
                mid = start + (end - start) / 2;
                if (sum[mid] - sum[i] + nums[i] == s){
                    end = mid;
                    break;
                }
                else if (sum[mid] - sum[i] + nums[i] &amp;lt; s) {
                    start = mid;
                }
                else {
                    end = mid;
                }
            }
            if (sum[start] - sum[i] + nums[i] &amp;gt;= s){
                ans = Math.min(ans, start - i + 1);
            }
            if (sum[end] - sum[i] + nums[i] &amp;gt;= s){
                ans = Math.min(ans, end - i + 1);
            }

        }
        return (ans == Integer.MAX_VALUE ? 0 : ans);
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;思路&lt;/h2&gt;
&lt;h3&gt;O(n) solution&lt;/h3&gt;
&lt;h3&gt;O(nlogn) solution&lt;/h3&gt;
&lt;p&gt;O(nlogn)的解法很不易想到，tag上提示为二分搜索，binary search的复杂度为O(logn)，那么在外层应该有一个for循环。&lt;/p&gt;</summary><category term="Algorithm Binary Search"></category></entry><entry><title>Search a 2D Matrix</title><link href="http://www.zhangge208.com/pages/2015/09/09/search-a-2d-matrix.html" rel="alternate"></link><updated>2015-09-09T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-09-09:pages/2015/09/09/search-a-2d-matrix.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Search a 2D Matrix&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:&lt;/p&gt;
&lt;p&gt;Integers in each row are sorted from left to right.
The first integer of each row is greater than the last integer of the previous row.
For example,&lt;/p&gt;
&lt;p&gt;Consider the following matrix:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;[
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Given &lt;strong&gt;target&lt;/strong&gt; = &lt;code&gt;3&lt;/code&gt;, return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return false;
        }
        int row = matrix.length;
        int col = matrix[0].length;
        int start = 0;
        int end = row * col - 1;
        while (start + 1 &amp;lt; end) {
            int mid = start + (end - start) / 2;
            int x = mid / col ;
            int y = mid % col ;
            if (matrix[x][y] == target) {
                end = mid;
            }
            else if (matrix[x][y] &amp;lt; target) {
                start = mid;
            }
            else {
                end = mid;
            }
        }
        if (matrix[start / col][start % col] == target) {
            return true;
        }
        if (matrix[end / col][end % col] == target) {
            return true;
        }

        return false;
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;参考Python中用列表表示多维数组的想法，可以将整个二维数组展成一维的数组，这样直接使用二分搜索就可以了。&lt;/p&gt;
&lt;p&gt;一个小trick:如何用mid表示二维数组的下标呢？&lt;/p&gt;
&lt;p&gt;answer：行下标为mid / col,列下标为mid % col&lt;/p&gt;</summary><category term="Algorithm Binary Search"></category></entry><entry><title>Search a 2D Matrix II</title><link href="http://www.zhangge208.com/pages/2015/09/09/search-a-2d-matrix-ii.html" rel="alternate"></link><updated>2015-09-09T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-09-09:pages/2015/09/09/search-a-2d-matrix-ii.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Search a 2D Matrix II&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:&lt;/p&gt;
&lt;p&gt;Integers in each row are sorted in ascending from left to right.
Integers in each column are sorted in ascending from top to bottom.
For example,&lt;/p&gt;
&lt;p&gt;Consider the following matrix:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Given &lt;strong&gt;target&lt;/strong&gt; = 5, return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Given &lt;strong&gt;target&lt;/strong&gt; = 20, return &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0) {
            return false;
        }

        if (matrix[0] == null || matrix[0].length == 0) {
            return false;
        }

        int rowBegin = 0;
        int rowEnd = matrix.length - 1;
        int colBegin = 0;
        int colEnd = matrix[0].length - 1;

        while(colEnd &amp;gt;= colBegin &amp;amp;&amp;amp; rowBegin &amp;lt;= rowEnd) {
            int temp = matrix[rowBegin][colEnd];
            if(target == temp) {
                return true;
            }
            else if (target &amp;lt; temp) {
                colEnd--;
            }
            else if (target &amp;gt; temp) {
                rowBegin++;
            }

        }

        return false;
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;这道题目的难度主要在于并不是全部有序的，仅存在行有序与列有序，这时需要观察数组的特殊元素，例如四个角上的元素，并且选择的特殊元素能使用上有序的属性。那么左上角和右下角的元素就不合适了，左上角的元素是数组中最小的，右下角元素是数组中最大的。而右上角元素在这一行中是最大的，但在列中却是这一列最小的。左下角也一样，在列排序中是最大的，在行排序中是最小的。代码中选择的是右上角元素，在target小于该元素时，移动列下标，在更小的一列寻找target，而在target大于该元素时，那么移动行下标，在更大的一行寻找target&lt;/p&gt;</summary><category term="Algorithm Binary Search"></category></entry><entry><title>Search for a Range</title><link href="http://www.zhangge208.com/pages/2015/09/09/search-for-a-range.html" rel="alternate"></link><updated>2015-09-09T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-09-09:pages/2015/09/09/search-for-a-range.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Search for a Range&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Given a sorted array of integers, find the starting and ending position of a given target value.&lt;/p&gt;
&lt;p&gt;Your algorithm's runtime complexity must be in the order of O(log n).&lt;/p&gt;
&lt;p&gt;If the target is not found in the array, return &lt;code&gt;[-1, -1]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example,
Given &lt;code&gt;[5, 7, 7, 8, 8, 10]&lt;/code&gt; and target value 8,
return &lt;code&gt;[3, 4]&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public int[] searchRange(int[] nums, int target) {
        int[] result = new int[2];
        if (nums == null || nums.length == 0) {
            return result;
        }
        //search for left bound
        int start = 0;
        int end = nums.length - 1;
        int mid = 0;
        while (start + 1 &amp;lt; end) {
            mid = start + (end - start) / 2;
            if (target == nums[mid]) {
                end = mid;        
            }
            else if (target &amp;gt; nums[mid]) {
                start = mid;
            }
            else {
                end = mid;
            }
        }
        if (nums[start] == target) {
            result[0] = start;
        }
        else if (nums[end] == target) {
            result[0] = end;
        }
        else {
            result[0] = result[1] = -1;
            return result;
        }

        start = 0;
        end = nums.length - 1;
        while (start + 1 &amp;lt; end) {
            mid = start + (end - start) / 2;
            if (target == nums[mid]) {
                start = mid;        
            }
            else if (target &amp;gt; nums[mid]) {
                start = mid;
            }
            else {
                end = mid;
            }

        }
        if (nums[end] == target) {
            result[1] = end;
        }
        else if (nums[start] == target){
            result[1] = start;
        }
        else {
            result[0] = result[1] = -1;
            return result;
        }
        return result;

    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;这道题目是练习寻找二分搜索的边界。运用二分搜索模板可以找到左边界，那么该如何寻找右边界呢，只需要将模板稍稍修改即可，寻找左边界时，
如果target == nums[mid]，那么令end = mid；寻找右边界时，
如果target == nums[mid]，那么令start = mid。想想其中原因，若二分法的end越小，则越靠近左边，而start越大则越靠近右边。故寻找到了左右边界。&lt;br /&gt;
&lt;/p&gt;</summary><category term="Algorithm Binary Search"></category></entry><entry><title>Search in Rotated Sorted Array</title><link href="http://www.zhangge208.com/pages/2015/09/09/search-in-rotated-sorted-array.html" rel="alternate"></link><updated>2015-09-09T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-09-09:pages/2015/09/09/search-in-rotated-sorted-array.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Search in Rotated Sorted Array&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Suppose a sorted array is rotated at some pivot unknown to you beforehand.&lt;/p&gt;
&lt;p&gt;(i.e., &lt;code&gt;0 1 2 4 5 6 7&lt;/code&gt; might become &lt;code&gt;4 5 6 7 0 1 2&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;You are given a target value to search. If found in the array return its index, otherwise return -1.&lt;/p&gt;
&lt;p&gt;You may assume no duplicate exists in the array.&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public int search(int[] nums, int target) {
        if (nums.length == 0 || nums == null) {
            return -1;
        }

        int start = 0;
        int end = nums.length - 1;

        while (start + 1 &amp;lt; end) {
            int mid = start + (end - start) / 2;
            if (nums[mid] == target) {
                end = mid;
            }
            else if (nums[mid] &amp;lt; nums[end]) {
                if (nums[mid] &amp;lt;= target &amp;amp;&amp;amp; target &amp;lt;= nums[end]) {
                    start = mid;
                }
                else {
                    end = mid;
                }
            }
            // nums[mid] &amp;gt; nums[start]
            else {
                if (nums[mid] &amp;gt;= target &amp;amp;&amp;amp; target &amp;gt;= nums[start]) {
                    end = mid;
                }
                else {
                    start = mid;
                }
            }
        }

        if (nums[start] == target) {
            return start;
        }
        if (nums[end] == target) {
            return end;
        }

        return -1;

    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;在数组发生旋转后会有两种情况产生，以[0,1,2,3,4,5,6]为例：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;旋转后形如[3,4,5,6,0,1,2],即较小的数发生了翻转，但前半部分仍然有序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;旋转后形如[5,6,0,1,2,3,4],即较大的数发生了翻转，但后半部分仍然有序&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为使用二分搜索，那么必须保持使用区间的有序性,所以要在nums[mid] &amp;lt;= target &amp;amp;&amp;amp; target &amp;lt;= nums[end] 或 nums[mid] &amp;gt;= target &amp;amp;&amp;amp; target &amp;gt;= nums[start]这两个有序部分进行二分搜索&lt;/p&gt;</summary><category term="Algorithm Binary Search"></category></entry><entry><title>Search Insert Position</title><link href="http://www.zhangge208.com/pages/2015/09/09/search-insert-position.html" rel="alternate"></link><updated>2015-09-09T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-09-09:pages/2015/09/09/search-insert-position.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Search Insert Position&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.&lt;/p&gt;
&lt;p&gt;You may assume no duplicates in the array.&lt;/p&gt;
&lt;p&gt;Here are few examples.
[1,3,5,6], 5 → 2&lt;/p&gt;
&lt;p&gt;[1,3,5,6], 2 → 1&lt;/p&gt;
&lt;p&gt;[1,3,5,6], 7 → 4&lt;/p&gt;
&lt;p&gt;[1,3,5,6], 0 → 0&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;version 1：first postion &amp;gt;= target
public class Solution {
    public int searchInsert(int[] nums, int target) {
        if (nums == null || nums.length == 0) {
            return -1;
        }
        int start = 0;
        int end = nums.length - 1;
        while (start + 1 &amp;lt; end) {
            int mid = start + (end - start) / 2;
            if (target &amp;lt; nums[mid]) {
                end = mid;
            }
            else if (target &amp;gt; nums[mid]) {
                start = mid;
            }
            else {
                end = mid;
            }
        }

        if (nums[start] &amp;gt;= target) {
            return start;
        }
        else if (nums[end] &amp;gt;= target) {
            return end;
        }
        //nums[end] &amp;lt; target
        else {
            return end + 1;
        }

    }
}

version 2：last postion &amp;lt; target
public class Solution {
    public int searchInsert(int[] nums, int target) {
        if (nums == null || nums.length == 0) {
            return -1;
        }

        int start = 0;
        int end = nums.length - 1;
        while (start + 1 &amp;lt; end) {
            int mid = start + (end -start) / 2;
            if (target &amp;gt; nums[mid]) {
                start = mid;
            }
            else {
                end = mid;
            }
        }
        if (target &amp;lt; nums[0]) {
            return 0;
        }
        if (nums[start] == target) {
            return start;
        }
        if (nums[end] == target) {
            return end;
        }   
        if (nums[end] &amp;lt; target){
            return end + 1;
        }
        return start + 1;
    }
 }
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;如果target在数组中，那么可直接运用二分搜索的模板，但需要处理的一个问题是，如果target不在数组中，那么应该把它放在哪里合适呢？
直接地，有两种思路：&lt;/p&gt;
&lt;p&gt;1.找到first postion &amp;gt;= target的地方，把target放在这个位置&lt;/p&gt;
&lt;p&gt;2.找到last postion &amp;lt; target的地方，把target放在这个位置&lt;/p&gt;
&lt;p&gt;值得注意的是，对一些边界的问题需要进行考虑&lt;/p&gt;
&lt;p&gt;1.使用第一种思路时，要注意处理nums[end] &amp;lt; target的情况&lt;/p&gt;
&lt;p&gt;2.使用第二种思路时，要注意处理target &amp;lt; nums[0]的情况&lt;/p&gt;</summary><category term="Algorithm Binary Search"></category></entry><entry><title>Leetcode@Convert Sorted List to Binary Search Tree</title><link href="http://www.zhangge208.com/pages/2015/06/30/leetcodeconvert-sorted-list-to-binary-search-tree.html" rel="alternate"></link><updated>2015-06-30T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-06-30:pages/2015/06/30/leetcodeconvert-sorted-list-to-binary-search-tree.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Convert Sorted List to Binary Search Tree&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;与&lt;a href="http://www.zhangge208.com/pages/2015/06/29/leetcodeconvert-sorted-array-to-binary-search-tree.html"&gt;Convert Sorted Array to Binary Search Tree&lt;/a&gt;的思路很像，首先是得找到根节点，但考虑到是链表，没法直接到中间的元素，只能依次移动指针，联想到中序遍历与BST的关系，我们依据inorder来构造BST，前半部分为左子树，然后根节点，后半部分为右子树。&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * Definition for singly-linked list.&lt;/span&gt;
&lt;span class="cm"&gt; * public class ListNode {&lt;/span&gt;
&lt;span class="cm"&gt; *     int val;&lt;/span&gt;
&lt;span class="cm"&gt; *     ListNode next;&lt;/span&gt;
&lt;span class="cm"&gt; *     ListNode(int x) { val = x; }&lt;/span&gt;
&lt;span class="cm"&gt; * }&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * Definition for a binary tree node.&lt;/span&gt;
&lt;span class="cm"&gt; * public class TreeNode {&lt;/span&gt;
&lt;span class="cm"&gt; *     int val;&lt;/span&gt;
&lt;span class="cm"&gt; *     TreeNode left;&lt;/span&gt;
&lt;span class="cm"&gt; *     TreeNode right;&lt;/span&gt;
&lt;span class="cm"&gt; *     TreeNode(int x) { val = x; }&lt;/span&gt;
&lt;span class="cm"&gt; * }&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
public&lt;span class="w"&gt; &lt;/span&gt;class&lt;span class="w"&gt; &lt;/span&gt;Solution&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;private&lt;span class="w"&gt; &lt;/span&gt;ListNode&lt;span class="w"&gt; &lt;/span&gt;current&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;public&lt;span class="w"&gt; &lt;/span&gt;TreeNode&lt;span class="w"&gt; &lt;/span&gt;sortedListToBST&lt;span class="o"&gt;(&lt;/span&gt;ListNode&lt;span class="w"&gt; &lt;/span&gt;head&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;int&lt;span class="w"&gt; &lt;/span&gt;size&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;getLength&lt;span class="o"&gt;(&lt;/span&gt;head&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;current&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;head&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;sortedListToBSTHelper&lt;span class="o"&gt;(&lt;/span&gt;size&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;private&lt;span class="w"&gt; &lt;/span&gt;int&lt;span class="w"&gt; &lt;/span&gt;getLength&lt;span class="o"&gt;(&lt;/span&gt;ListNode&lt;span class="w"&gt; &lt;/span&gt;head&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;int&lt;span class="w"&gt; &lt;/span&gt;length&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;while&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;head&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;null&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;length&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;head&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;head&lt;span class="o"&gt;.&lt;/span&gt;next&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;length&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;public&lt;span class="w"&gt; &lt;/span&gt;TreeNode&lt;span class="w"&gt; &lt;/span&gt;sortedListToBSTHelper&lt;span class="o"&gt;(&lt;/span&gt;int&lt;span class="w"&gt; &lt;/span&gt;size&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;size&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;null&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;TreeNode&lt;span class="w"&gt; &lt;/span&gt;left&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;sortedListToBSTHelper&lt;span class="o"&gt;(&lt;/span&gt;size&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;TreeNode&lt;span class="w"&gt; &lt;/span&gt;root&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;new&lt;span class="w"&gt; &lt;/span&gt;TreeNode&lt;span class="o"&gt;(&lt;/span&gt;current&lt;span class="o"&gt;.&lt;/span&gt;val&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;current&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;current&lt;span class="o"&gt;.&lt;/span&gt;next&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;TreeNode&lt;span class="w"&gt; &lt;/span&gt;right&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;sortedListToBSTHelper&lt;span class="o"&gt;(&lt;/span&gt;size&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;size&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;root&lt;span class="o"&gt;.&lt;/span&gt;left&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;left&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;root&lt;span class="o"&gt;.&lt;/span&gt;right&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;right&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;root&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Leetcode Binary Tree"></category></entry><entry><title>Leetcode@Convert Sorted Array to Binary Search Tree</title><link href="http://www.zhangge208.com/pages/2015/06/29/leetcodeconvert-sorted-array-to-binary-search-tree.html" rel="alternate"></link><updated>2015-06-29T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-06-29:pages/2015/06/29/leetcodeconvert-sorted-array-to-binary-search-tree.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Convert Sorted Array to Binary Search Tree&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Given an array where elements are sorted in ascending order, convert it to a height balanced BST.&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;按照题目要求，第一想法是得到树的根节点，如果没有构建平衡二叉搜索树的要求，那很容易，联想BST和binary search的关系，选择排序数组中间元素作为根节点，元素左边的全部元素作为左子树，右边全部元素作为右子树，然后用同样的方法寻找根节点，递归。&lt;/p&gt;
&lt;p&gt;需要注意对边界的处理，必须满足BST的定义。&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * Definition for a binary tree node.&lt;/span&gt;
&lt;span class="cm"&gt; * public class TreeNode {&lt;/span&gt;
&lt;span class="cm"&gt; *     int val;&lt;/span&gt;
&lt;span class="cm"&gt; *     TreeNode left;&lt;/span&gt;
&lt;span class="cm"&gt; *     TreeNode right;&lt;/span&gt;
&lt;span class="cm"&gt; *     TreeNode(int x) { val = x; }&lt;/span&gt;
&lt;span class="cm"&gt; * }&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
public&lt;span class="w"&gt; &lt;/span&gt;class&lt;span class="w"&gt; &lt;/span&gt;Solution&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;public&lt;span class="w"&gt; &lt;/span&gt;TreeNode&lt;span class="w"&gt; &lt;/span&gt;sortedArrayToBST&lt;span class="o"&gt;(&lt;/span&gt;int&lt;span class="err"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;nums&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;nums&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;null&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;null&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;buildTree&lt;span class="o"&gt;(&lt;/span&gt;nums&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;nums&lt;span class="o"&gt;.&lt;/span&gt;length&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;private&lt;span class="w"&gt; &lt;/span&gt;TreeNode&lt;span class="w"&gt; &lt;/span&gt;buildTree&lt;span class="o"&gt;(&lt;/span&gt;int&lt;span class="err"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;nums&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;int&lt;span class="w"&gt; &lt;/span&gt;start&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;int&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;end&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;start&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;end&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;null&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;TreeNode&lt;span class="w"&gt; &lt;/span&gt;node&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;new&lt;span class="w"&gt; &lt;/span&gt;TreeNode&lt;span class="o"&gt;(&lt;/span&gt;nums&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;end&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;start&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;node&lt;span class="o"&gt;.&lt;/span&gt;left&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;buildTree&lt;span class="o"&gt;(&lt;/span&gt;nums&lt;span class="o"&gt;,&lt;/span&gt;start&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;end&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;start&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;node&lt;span class="o"&gt;.&lt;/span&gt;right&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;buildTree&lt;span class="o"&gt;(&lt;/span&gt;nums&lt;span class="o"&gt;,(&lt;/span&gt;&lt;span class="kr"&gt;end&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;start&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;end&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;node&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Leetcode Binary Tree"></category></entry><entry><title>Leetcode@Leetcode@Invert Binary Tree</title><link href="http://www.zhangge208.com/pages/2015/06/13/leetcodeleetcodeinvert-binary-tree.html" rel="alternate"></link><updated>2015-06-13T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-06-13:pages/2015/06/13/leetcodeleetcodeinvert-binary-tree.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Leetcode@Invert Binary Tree&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Invert a binary tree.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;     4
   /   \
  2     7
 / \   / \
1   3 6   9
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;to&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;     4
   /   \
  7     2
 / \   / \
9   6 3   1
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;非递归的还没想出来，不会做，那就来递归的吧先，递归很简单，交换左右节点就跟交换a,b两个数一样，需要一个中间变量，先把左子树的指针赋给中间变量，然后交换。&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * Definition for a binary tree node.&lt;/span&gt;
&lt;span class="cm"&gt; * public class TreeNode {&lt;/span&gt;
&lt;span class="cm"&gt; *     int val;&lt;/span&gt;
&lt;span class="cm"&gt; *     TreeNode left;&lt;/span&gt;
&lt;span class="cm"&gt; *     TreeNode right;&lt;/span&gt;
&lt;span class="cm"&gt; *     TreeNode(int x) { val = x; }&lt;/span&gt;
&lt;span class="cm"&gt; * }&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
public&lt;span class="w"&gt; &lt;/span&gt;class&lt;span class="w"&gt; &lt;/span&gt;Solution&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;public&lt;span class="w"&gt; &lt;/span&gt;TreeNode&lt;span class="w"&gt; &lt;/span&gt;invertTree&lt;span class="o"&gt;(&lt;/span&gt;TreeNode&lt;span class="w"&gt; &lt;/span&gt;root&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;root&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;null&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;root&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;TreeNode&lt;span class="w"&gt; &lt;/span&gt;temp&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;root&lt;span class="o"&gt;.&lt;/span&gt;left&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;root&lt;span class="o"&gt;.&lt;/span&gt;left&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;root&lt;span class="o"&gt;.&lt;/span&gt;right&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;root&lt;span class="o"&gt;.&lt;/span&gt;right&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;temp&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;invertTree&lt;span class="o"&gt;(&lt;/span&gt;root&lt;span class="o"&gt;.&lt;/span&gt;left&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;invertTree&lt;span class="o"&gt;(&lt;/span&gt;root&lt;span class="o"&gt;.&lt;/span&gt;right&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;root&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Leetcode Binary Tree"></category></entry><entry><title>Leetcode@Validate Binary Search Tree</title><link href="http://www.zhangge208.com/pages/2015/06/13/leetcodevalidate-binary-search-tree.html" rel="alternate"></link><updated>2015-06-13T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-06-13:pages/2015/06/13/leetcodevalidate-binary-search-tree.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Leetcode@Validate Binary Search Tree&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Given a binary tree, determine if it is a valid binary search tree (BST).&lt;/p&gt;
&lt;p&gt;Assume a BST is defined as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The left subtree of a node contains only nodes with keys less - than the node's key.&lt;/li&gt;
&lt;li&gt;The right subtree of a node contains only nodes with keys greater than the node's key.&lt;/li&gt;
&lt;li&gt;Both the left and right subtrees must also be binary search trees.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;1.递归：设置上下限(&lt;a href="http://blog.csdn.net/fightforyourdream/article/details/14444883"&gt;http://blog.csdn.net/fightforyourdream/article/details/14444883&lt;/a&gt;)，在递归左右子树时为它们设置最大值、最小值，如果节点值超过限定，肯定不是，然后下一次递归时将上下限继续传递下去&lt;/p&gt;
&lt;p&gt;2.递归：分治法递归求解&lt;/p&gt;
&lt;p&gt;3.非递归：栈实现，对树进行中序遍历，然后看是否从左到右有序&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * Definition for a binary tree node.&lt;/span&gt;
&lt;span class="cm"&gt; * public class TreeNode {&lt;/span&gt;
&lt;span class="cm"&gt; *     int val;&lt;/span&gt;
&lt;span class="cm"&gt; *     TreeNode left;&lt;/span&gt;
&lt;span class="cm"&gt; *     TreeNode right;&lt;/span&gt;
&lt;span class="cm"&gt; *     TreeNode(int x) { val = x; }&lt;/span&gt;
&lt;span class="cm"&gt; * }&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
public&lt;span class="w"&gt; &lt;/span&gt;class&lt;span class="w"&gt; &lt;/span&gt;Solution&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;public&lt;span class="w"&gt; &lt;/span&gt;boolean&lt;span class="w"&gt; &lt;/span&gt;isValidBST&lt;span class="o"&gt;(&lt;/span&gt;TreeNode&lt;span class="w"&gt; &lt;/span&gt;root&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;isValidBST&lt;span class="o"&gt;(&lt;/span&gt;root&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;Long&lt;span class="o"&gt;.&lt;/span&gt;MIN_VALUE&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;Long&lt;span class="o"&gt;.&lt;/span&gt;MAX_VALUE&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;private&lt;span class="w"&gt; &lt;/span&gt;boolean&lt;span class="w"&gt; &lt;/span&gt;isValidBST&lt;span class="o"&gt;(&lt;/span&gt;TreeNode&lt;span class="w"&gt; &lt;/span&gt;root&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;long&lt;span class="w"&gt; &lt;/span&gt;min&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;long&lt;span class="w"&gt; &lt;/span&gt;max&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;root&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;null&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;true&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;root&lt;span class="o"&gt;.&lt;/span&gt;val&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;min&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;||&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;root&lt;span class="o"&gt;.&lt;/span&gt;val&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;max&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;false&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;isValidBST&lt;span class="o"&gt;(&lt;/span&gt;root&lt;span class="o"&gt;.&lt;/span&gt;left&lt;span class="o"&gt;,&lt;/span&gt;min&lt;span class="o"&gt;,&lt;/span&gt;root&lt;span class="o"&gt;.&lt;/span&gt;val&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;isValidBST&lt;span class="o"&gt;(&lt;/span&gt;root&lt;span class="o"&gt;.&lt;/span&gt;right&lt;span class="o"&gt;,&lt;/span&gt;root&lt;span class="o"&gt;.&lt;/span&gt;val&lt;span class="o"&gt;,&lt;/span&gt;max&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Leetcode Binary Tree"></category></entry><entry><title>Leetcode@Leetcode@Rotate List</title><link href="http://www.zhangge208.com/pages/2015/06/02/leetcodeleetcoderotate-list.html" rel="alternate"></link><updated>2015-06-02T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-06-02:pages/2015/06/02/leetcodeleetcoderotate-list.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Leetcode@Rotate List&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Given a list, rotate the list to the right by k places, where k is non-negative.&lt;/p&gt;
&lt;p&gt;For example:
Given &lt;code&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL&lt;/code&gt; and k = &lt;code&gt;2&lt;/code&gt;,
return &lt;code&gt;4-&amp;gt;5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;NULL&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;把问题分割，题目要求部分翻转，那么首先要得到开始翻转的位置
这与Remove Nth Node From End of List的思路一致，运用快慢指针，得到要翻转的位置，这部分问题解决。然后就是链表的连接，由于翻转后并不知道头节点是谁，所以需要dummy node来解决这一问题。然后画个图，搞清每一步的连接。链表连接的问题还是要多画图分析。
题目中有个小陷阱，就是翻转位置标识k，并没有说明k有多大，所以需要进行取余操作，那么就先需要知道链表的长度，链表长度的得到是很简单的，遍历一遍，拿一个计数器记录就好。
关于边界的考虑，一定要记得异常处理，首先是链表判空；然后在进行快慢指针的过程时，要保证fast-&amp;gt;next不为空；在获取链表长度时也需要让链表head！= NULL。&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Solution&lt;/span&gt; {
&lt;span class="n"&gt;public:&lt;/span&gt;
    &lt;span class="n"&gt;ListNode&lt;/span&gt; *&lt;span class="n"&gt;rotateRight&lt;/span&gt;(&lt;span class="n"&gt;ListNode&lt;/span&gt; *&lt;span class="n"&gt;head&lt;/span&gt;, &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;) {
        &lt;span class="k"&gt;if&lt;/span&gt;(&lt;span class="n"&gt;head&lt;/span&gt; == &lt;span class="n"&gt;NULL&lt;/span&gt; )
        {
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;;
        }

        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt; = &lt;span class="n"&gt;getlength&lt;/span&gt;(&lt;span class="n"&gt;head&lt;/span&gt;);
        &lt;span class="n"&gt;k&lt;/span&gt; = &lt;span class="n"&gt;k&lt;/span&gt; % &lt;span class="n"&gt;length&lt;/span&gt;;

        &lt;span class="n"&gt;ListNode&lt;/span&gt; *&lt;span class="n"&gt;dummy&lt;/span&gt; = &lt;span class="nb"&gt;new&lt;/span&gt; &lt;span class="n"&gt;ListNode&lt;/span&gt;(-&lt;span class="mi"&gt;1&lt;/span&gt;);
        &lt;span class="n"&gt;dummy-&lt;/span&gt;&amp;gt;&lt;span class="k"&gt;next&lt;/span&gt; = &lt;span class="n"&gt;head&lt;/span&gt;;
        &lt;span class="n"&gt;head&lt;/span&gt; = &lt;span class="n"&gt;dummy&lt;/span&gt;;

        &lt;span class="n"&gt;ListNode&lt;/span&gt; *&lt;span class="n"&gt;fast&lt;/span&gt; = &lt;span class="n"&gt;dummy&lt;/span&gt;;
        &lt;span class="n"&gt;ListNode&lt;/span&gt; *&lt;span class="n"&gt;slow&lt;/span&gt; = &lt;span class="n"&gt;dummy&lt;/span&gt;;

        &lt;span class="k"&gt;for&lt;/span&gt;(&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; = &lt;span class="mi"&gt;0&lt;/span&gt;; &lt;span class="n"&gt;i&lt;/span&gt; &amp;lt; &lt;span class="n"&gt;k&lt;/span&gt;; &lt;span class="n"&gt;i&lt;/span&gt;++)
        {
            &lt;span class="n"&gt;fast&lt;/span&gt; = &lt;span class="n"&gt;fast-&lt;/span&gt;&amp;gt;&lt;span class="k"&gt;next&lt;/span&gt;;
        }

        &lt;span class="k"&gt;while&lt;/span&gt;(&lt;span class="n"&gt;fast-&lt;/span&gt;&amp;gt;&lt;span class="k"&gt;next&lt;/span&gt; != &lt;span class="n"&gt;NULL&lt;/span&gt;)
        {
            &lt;span class="n"&gt;fast&lt;/span&gt; = &lt;span class="n"&gt;fast-&lt;/span&gt;&amp;gt;&lt;span class="k"&gt;next&lt;/span&gt;;
            &lt;span class="n"&gt;slow&lt;/span&gt; = &lt;span class="n"&gt;slow-&lt;/span&gt;&amp;gt;&lt;span class="k"&gt;next&lt;/span&gt;;
        }

        &lt;span class="n"&gt;fast-&lt;/span&gt;&amp;gt;&lt;span class="k"&gt;next&lt;/span&gt; = &lt;span class="n"&gt;dummy-&lt;/span&gt;&amp;gt;&lt;span class="k"&gt;next&lt;/span&gt;;
        &lt;span class="n"&gt;dummy-&lt;/span&gt;&amp;gt;&lt;span class="k"&gt;next&lt;/span&gt; = &lt;span class="n"&gt;slow-&lt;/span&gt;&amp;gt;&lt;span class="k"&gt;next&lt;/span&gt;;
        &lt;span class="n"&gt;slow-&lt;/span&gt;&amp;gt;&lt;span class="k"&gt;next&lt;/span&gt; = &lt;span class="n"&gt;NULL&lt;/span&gt;;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;dummy-&lt;/span&gt;&amp;gt;&lt;span class="k"&gt;next&lt;/span&gt;;
    }
&lt;span class="n"&gt;private:&lt;/span&gt;
    &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;getlength&lt;/span&gt;(&lt;span class="n"&gt;ListNode&lt;/span&gt; *&lt;span class="n"&gt;head&lt;/span&gt;)
    {
        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt; = &lt;span class="mi"&gt;0&lt;/span&gt;;

        &lt;span class="k"&gt;while&lt;/span&gt;(&lt;span class="n"&gt;head&lt;/span&gt; != &lt;span class="n"&gt;NULL&lt;/span&gt;)
        {
            &lt;span class="n"&gt;length&lt;/span&gt;++;
            &lt;span class="n"&gt;head&lt;/span&gt; = &lt;span class="n"&gt;head-&lt;/span&gt;&amp;gt;&lt;span class="k"&gt;next&lt;/span&gt;;
        }
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;;
    }
};
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Leetcode Linked List"></category></entry><entry><title>Leetcode@Remove Linked List Elements</title><link href="http://www.zhangge208.com/pages/2015/06/02/leetcoderemove-linked-list-elements.html" rel="alternate"></link><updated>2015-06-02T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-06-02:pages/2015/06/02/leetcoderemove-linked-list-elements.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Leetcode@Remove Linked List Elements&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Remove all elements from a linked list of integers that have value val.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Given:&lt;/em&gt;&lt;/strong&gt; 1 --&amp;gt; 2 --&amp;gt; 6 --&amp;gt; 3 --&amp;gt; 4 --&amp;gt; 5 --&amp;gt; 6, val = 6&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Return:&lt;/em&gt;&lt;/strong&gt; 1 --&amp;gt; 2 --&amp;gt; 3 --&amp;gt; 4 --&amp;gt; 5&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;基础的链表操作题目。首先考虑到头节点可能会被修改，所以要使用dummynode，然后根据判断条件进行remove即可，现指针节点为p，p的后继节点的值若与给定的val相等，则令p指向p后继的后继即可移除p现在的后继。注意边界条件的处理。&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * Definition for singly-linked list.&lt;/span&gt;
&lt;span class="cm"&gt; * public class ListNode {&lt;/span&gt;
&lt;span class="cm"&gt; *     int val;&lt;/span&gt;
&lt;span class="cm"&gt; *     ListNode next;&lt;/span&gt;
&lt;span class="cm"&gt; *     ListNode(int x) { val = x; }&lt;/span&gt;
&lt;span class="cm"&gt; * }&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
public&lt;span class="w"&gt; &lt;/span&gt;class&lt;span class="w"&gt; &lt;/span&gt;Solution&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;public&lt;span class="w"&gt; &lt;/span&gt;ListNode&lt;span class="w"&gt; &lt;/span&gt;removeElements&lt;span class="o"&gt;(&lt;/span&gt;ListNode&lt;span class="w"&gt; &lt;/span&gt;head&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;int&lt;span class="w"&gt; &lt;/span&gt;val&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;head&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;null&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;null&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;ListNode&lt;span class="w"&gt; &lt;/span&gt;dummy&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;new&lt;span class="w"&gt; &lt;/span&gt;ListNode&lt;span class="o"&gt;(-&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;dummy&lt;span class="o"&gt;.&lt;/span&gt;next&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;head&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;head&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;dummy&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;while&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;head&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;null&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;head&lt;span class="o"&gt;.&lt;/span&gt;next&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;null&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;head&lt;span class="o"&gt;.&lt;/span&gt;next&lt;span class="o"&gt;.&lt;/span&gt;val&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;val&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;head&lt;span class="o"&gt;.&lt;/span&gt;next&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;head&lt;span class="o"&gt;.&lt;/span&gt;next&lt;span class="o"&gt;.&lt;/span&gt;next&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kr"&gt;else&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;head&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;head&lt;span class="o"&gt;.&lt;/span&gt;next&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;dummy&lt;span class="o"&gt;.&lt;/span&gt;next&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Leetcode Linked List"></category></entry><entry><title>Leetcode@Kth Largest Element in an Array</title><link href="http://www.zhangge208.com/pages/2015/05/28/leetcodekth-largest-element-in-an-array.html" rel="alternate"></link><updated>2015-05-28T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-05-28:pages/2015/05/28/leetcodekth-largest-element-in-an-array.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Leetcode@Kth Largest Element in an Array&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.&lt;/p&gt;
&lt;p&gt;For example,
Given [3,2,1,5,6,4] and k = 2, return 5.&lt;/p&gt;
&lt;p&gt;Note: 
You may assume k is always valid, 1 ≤ k ≤ array's length.&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;使用优先队列来解决。由于题目是求第k大的数，反过来也就是求第n-k+1小的数，那么只需要生成一个队长为k的优先队列，把n个数中k个最大的数放入队列中即可，此时返回队头即可。所以，对于nums中前k个数，我们全部放入优先队列中；对于剩下的n-k个元素，我们挨个将其与现有队头比较，如果比现有队头大，那么更新队头，原队头出队，元素入队。&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public int findKthLargest(int[] nums, int k) {
        PriorityQueue&amp;lt;Integer&amp;gt; queue = new PriorityQueue&amp;lt;Integer&amp;gt;(k);
        for (int i = 0; i &amp;lt; nums.length; i++){
            if (queue.size() &amp;lt; k){
                queue.add(nums[i]);
            }
            else{
                if (nums[i] &amp;gt; queue.peek()){
                    queue.remove();
                    queue.add(nums[i]);
                }
            }
        }
        return queue.remove();
    }
}
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Leetcode Heap"></category></entry><entry><title>Leetcode@Best Time to Buy and Sell Stock I</title><link href="http://www.zhangge208.com/pages/2015/05/26/leetcodebest-time-to-buy-and-sell-stock-i.html" rel="alternate"></link><updated>2015-05-26T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-05-26:pages/2015/05/26/leetcodebest-time-to-buy-and-sell-stock-i.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Leetcode@Best Time to Buy and Sell Stock I&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;/p&gt;
&lt;p&gt;If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;动态规划的想法，属于sequence DP&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;state：f[i]代表前i天的最大收益&lt;/li&gt;
&lt;li&gt;function：f[i] = max(f[i-1],f[i-1]+prices[i]-prices[i-1])&lt;/li&gt;
&lt;li&gt;intialize:f[0] = 0&lt;/li&gt;
&lt;li&gt;answer:f[n] &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;代码&lt;/h2&gt;</summary><category term="Algorithm Leetcode Dynamic Programming"></category></entry><entry><title>Leetcode@Best Time to Buy and Sell Stock II</title><link href="http://www.zhangge208.com/pages/2015/05/26/leetcodebest-time-to-buy-and-sell-stock-ii.html" rel="alternate"></link><updated>2015-05-26T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-05-26:pages/2015/05/26/leetcodebest-time-to-buy-and-sell-stock-ii.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Leetcode@Best Time to Buy and Sell Stock II&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;/p&gt;
&lt;p&gt;Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;贪心的想法，既然能交易多次，那就把所有赚钱的时间段赚取的利益相加。首先要构造一个差值数组（前缀和数组？），即price_diff[i] = prices[i] - prices[i-1],然后把全部price_diff &amp;gt; 0的部分相加，即为最大利益&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Solution&lt;/span&gt; {
&lt;span class="n"&gt;public:&lt;/span&gt;
    &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;maxProfit&lt;/span&gt;(&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;int&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;&amp;amp;prices&lt;/span&gt;) {
        &lt;span class="k"&gt;if&lt;/span&gt;(&lt;span class="n"&gt;prices&lt;/span&gt;.&lt;span class="n"&gt;size&lt;/span&gt;() &amp;lt; &lt;span class="mi"&gt;2&lt;/span&gt;) 
        {
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;;
        }
        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;price_diff&lt;/span&gt; = &lt;span class="mi"&gt;0&lt;/span&gt;;
        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cur_price&lt;/span&gt; = &lt;span class="n"&gt;prices&lt;/span&gt;[&lt;span class="mi"&gt;0&lt;/span&gt;];
        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="nb"&gt;sum&lt;/span&gt; = &lt;span class="mi"&gt;0&lt;/span&gt;;
        &lt;span class="k"&gt;for&lt;/span&gt;(&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; = &lt;span class="mi"&gt;1&lt;/span&gt;; &lt;span class="n"&gt;i&lt;/span&gt; &amp;lt; &lt;span class="n"&gt;prices&lt;/span&gt;.&lt;span class="n"&gt;size&lt;/span&gt;(); &lt;span class="n"&gt;i&lt;/span&gt;++)
        {
            &lt;span class="n"&gt;price_diff&lt;/span&gt; = &lt;span class="n"&gt;prices&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;]-&lt;span class="n"&gt;cur_price&lt;/span&gt;;
            &lt;span class="n"&gt;cur_price&lt;/span&gt; = &lt;span class="n"&gt;prices&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;];
            &lt;span class="k"&gt;if&lt;/span&gt;(&lt;span class="n"&gt;price_diff&lt;/span&gt; &amp;gt; &lt;span class="mi"&gt;0&lt;/span&gt;) &lt;span class="nb"&gt;sum&lt;/span&gt; += &lt;span class="n"&gt;price_diff&lt;/span&gt;;
        }
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;sum&lt;/span&gt;;
    }
};
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Leetcode Dynamic Programming"></category></entry><entry><title>Leetcode@Best Time to Buy and Sell Stock III</title><link href="http://www.zhangge208.com/pages/2015/05/26/leetcodebest-time-to-buy-and-sell-stock-iii.html" rel="alternate"></link><updated>2015-05-26T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-05-26:pages/2015/05/26/leetcodebest-time-to-buy-and-sell-stock-iii.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Leetcode@Best Time to Buy and Sell Stock III&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;/p&gt;
&lt;p&gt;Design an algorithm to find the maximum profit. You may complete at most two transactions.&lt;/p&gt;
&lt;p&gt;Note:
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;动态规划+前后遍历&lt;/p&gt;
&lt;p&gt;基本的想法是分成两个时间段，对于某一天j，计算之前的max profit和之后的max profit。&lt;/p&gt;
&lt;p&gt;即寻找一个点j，将原来的prices[0..n-1]分割成[0..j]和[j..n-1]两个子区间，分别求两段最大的收益，l_profit和r_profit，profit = l_profit + r_profit。然后用O(n)的时间在[0...n-1]上选择使得profit最大的j，返回最大的profit。&lt;/p&gt;
&lt;p&gt;对于点j，求price[0..j]的最大profit时，很多工作是重复的，在求price[0..j-1]的最大profit中已经做过了。Best Time to Buy and Sell Stock I的dp解法可以在O(1)的时间从price[0..j-1]推出price[0..j]的最大profit。
难点在于如何从price[j..n-1]推出price[j+1..n-1]，反过来思考，我们可以用O(1)的时间由price[j+1..n-1]推出price[j..n-1]。
所以进行前后遍历，即可得到结果。前后遍历的题目还有一些。&lt;/p&gt;
&lt;p&gt;整体思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组l[i]记录了price[0..i]的最大profit，&lt;/li&gt;
&lt;li&gt;数组r[i]记录了price[i..n]的最大profit。&lt;/li&gt;
&lt;li&gt;已知l[i]，求l[i+1]是简单的，同样已知r[i]，求r[i-1]也很容易。&lt;/li&gt;
&lt;li&gt;用O(n)的时间找出最大的l[i]+r[i]，即为题目所求。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Solution&lt;/span&gt; {
&lt;span class="n"&gt;public:&lt;/span&gt;
    &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;maxProfit&lt;/span&gt;(&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;int&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;&amp;amp;prices&lt;/span&gt;) {
        &lt;span class="k"&gt;if&lt;/span&gt;(&lt;span class="n"&gt;prices&lt;/span&gt;.&lt;span class="n"&gt;size&lt;/span&gt;() &amp;lt; &lt;span class="mi"&gt;2&lt;/span&gt;)
        {
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;;
        }
        &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;int&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;(&lt;span class="n"&gt;prices&lt;/span&gt;.&lt;span class="n"&gt;size&lt;/span&gt;());
        &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;int&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;(&lt;span class="n"&gt;prices&lt;/span&gt;.&lt;span class="n"&gt;size&lt;/span&gt;());
        // &lt;span class="n"&gt;DP&lt;/span&gt; &lt;span class="nb"&gt;from&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="nb"&gt;to&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;;
        &lt;span class="n"&gt;left&lt;/span&gt;[&lt;span class="mi"&gt;0&lt;/span&gt;] = &lt;span class="mi"&gt;0&lt;/span&gt;;
        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;min_price&lt;/span&gt; = &lt;span class="n"&gt;prices&lt;/span&gt;[&lt;span class="mi"&gt;0&lt;/span&gt;];
        &lt;span class="k"&gt;for&lt;/span&gt; (&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; = &lt;span class="mi"&gt;1&lt;/span&gt;; &lt;span class="n"&gt;i&lt;/span&gt; &amp;lt; &lt;span class="n"&gt;prices&lt;/span&gt;.&lt;span class="n"&gt;size&lt;/span&gt;(); &lt;span class="n"&gt;i&lt;/span&gt;++) 
        {
            &lt;span class="n"&gt;min_price&lt;/span&gt; = &lt;span class="nb"&gt;min&lt;/span&gt;(&lt;span class="n"&gt;prices&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;], &lt;span class="n"&gt;min_price&lt;/span&gt;);
            &lt;span class="n"&gt;left&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;] = &lt;span class="nb"&gt;max&lt;/span&gt;(&lt;span class="n"&gt;left&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt; - &lt;span class="mi"&gt;1&lt;/span&gt;], &lt;span class="n"&gt;prices&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;] - &lt;span class="n"&gt;min_price&lt;/span&gt;);            
        }

        //&lt;span class="n"&gt;DP&lt;/span&gt; &lt;span class="nb"&gt;from&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="nb"&gt;to&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;;
        &lt;span class="n"&gt;right&lt;/span&gt;[&lt;span class="mi"&gt;0&lt;/span&gt;] = &lt;span class="mi"&gt;0&lt;/span&gt;;
        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;max_price&lt;/span&gt; = &lt;span class="n"&gt;prices&lt;/span&gt;[&lt;span class="n"&gt;prices&lt;/span&gt;.&lt;span class="n"&gt;size&lt;/span&gt;() - &lt;span class="mi"&gt;1&lt;/span&gt;];
        &lt;span class="k"&gt;for&lt;/span&gt; (&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; = &lt;span class="n"&gt;prices&lt;/span&gt;.&lt;span class="n"&gt;size&lt;/span&gt;() - &lt;span class="mi"&gt;2&lt;/span&gt;; &lt;span class="n"&gt;i&lt;/span&gt; &amp;gt;= &lt;span class="mi"&gt;0&lt;/span&gt;; &lt;span class="n"&gt;i--&lt;/span&gt;)
        {
            &lt;span class="n"&gt;max_price&lt;/span&gt; = &lt;span class="nb"&gt;max&lt;/span&gt;(&lt;span class="n"&gt;prices&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;],&lt;span class="n"&gt;max_price&lt;/span&gt;);
            &lt;span class="n"&gt;right&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;] = &lt;span class="nb"&gt;max&lt;/span&gt;(&lt;span class="n"&gt;right&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;], &lt;span class="n"&gt;max_price&lt;/span&gt; - &lt;span class="n"&gt;prices&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;]);
        }

        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;profit&lt;/span&gt; = &lt;span class="mi"&gt;0&lt;/span&gt;;
        &lt;span class="k"&gt;for&lt;/span&gt; (&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; = &lt;span class="mi"&gt;0&lt;/span&gt;; &lt;span class="n"&gt;i&lt;/span&gt; &amp;lt; &lt;span class="n"&gt;prices&lt;/span&gt;.&lt;span class="n"&gt;size&lt;/span&gt;(); &lt;span class="n"&gt;i&lt;/span&gt;++)
        {
            &lt;span class="n"&gt;profit&lt;/span&gt; = &lt;span class="nb"&gt;max&lt;/span&gt;(&lt;span class="n"&gt;left&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;] +&lt;span class="n"&gt;right&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;], &lt;span class="n"&gt;profit&lt;/span&gt;);
        }

        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;profit&lt;/span&gt;;
    }
};
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Leetcode Dynamic Programming"></category></entry><entry><title>Leetcode@Factorial Trailing Zeroes</title><link href="http://www.zhangge208.com/pages/2015/05/26/leetcodefactorial-trailing-zeroes.html" rel="alternate"></link><updated>2015-05-26T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-05-26:pages/2015/05/26/leetcodefactorial-trailing-zeroes.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Leetcode@Factorial Trailing Zeroes&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Given an integer n, return the number of trailing zeroes in n!.&lt;/p&gt;
&lt;p&gt;Note: Your solution should be in logarithmic time complexity.&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;考虑n!的质数因子。后缀0总是由质因子2和质因子5相乘得来的。如果可以计算2和5的个数，问题就解决了。考虑到2的个数总是大于等于5的个数。因此只要计录5的个数就可以了。那么如何计算n!的质因子中所有5的个数便成为难点。一个简单的方法是计算(n/5),除此之外，还有一件事情要考虑。诸如25，125之类的数字有不止一个5。处理这个问题也很简单，首先对n除以5，移除所有的单个5，然后除以25，移除额外的5，以此类推，直到 n / 5 == 0。&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Solution&lt;/span&gt; {
&lt;span class="n"&gt;public:&lt;/span&gt;
    &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;trailingZeroes&lt;/span&gt;(&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;) {
        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;numzero&lt;/span&gt; = &lt;span class="mi"&gt;0&lt;/span&gt;;
        &lt;span class="k"&gt;while&lt;/span&gt; (&lt;span class="n"&gt;n&lt;/span&gt; &amp;gt; &lt;span class="mi"&gt;0&lt;/span&gt;)
        {
            &lt;span class="n"&gt;numzero&lt;/span&gt; = &lt;span class="n"&gt;numzero&lt;/span&gt; + &lt;span class="n"&gt;n&lt;/span&gt; / &lt;span class="mi"&gt;5&lt;/span&gt;;
            &lt;span class="n"&gt;n&lt;/span&gt; = &lt;span class="n"&gt;n&lt;/span&gt; / &lt;span class="mi"&gt;5&lt;/span&gt;;
        }
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;numzero&lt;/span&gt;;

    }
};
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Math"></category></entry><entry><title>Leetcode@Majority Element</title><link href="http://www.zhangge208.com/pages/2015/05/26/leetcodemajority-element.html" rel="alternate"></link><updated>2015-05-26T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-05-26:pages/2015/05/26/leetcodemajority-element.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Leetcode@Majority Element&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.&lt;/p&gt;
&lt;p&gt;You may assume that the array is non-empty and the majority element always exist in the array.&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;抵消的思想，有一个假设的主元素candidate，计数器count，若为主元素，必须满足严格地大于n/2，那么当元素1（假设的主元素）与元素2不一样时，把这两个数均丢弃，count--,如果是主元素，仍然会剩下一些;当数1与数2相同时，count++;然而，在count == 0时，说明现在的元素并非是主元素，故令 candidate = num[i],重复以上过程。&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Solution&lt;/span&gt; {
&lt;span class="n"&gt;public:&lt;/span&gt;
    &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;majorityElement&lt;/span&gt;(&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;int&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;&amp;amp;num&lt;/span&gt;) {
        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;candidate&lt;/span&gt; = &lt;span class="mi"&gt;0&lt;/span&gt;;
        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="nb"&gt;count&lt;/span&gt; = &lt;span class="mi"&gt;0&lt;/span&gt;;
        &lt;span class="k"&gt;for&lt;/span&gt;(&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; = &lt;span class="mi"&gt;0&lt;/span&gt;;&lt;span class="n"&gt;i&lt;/span&gt; &amp;lt; &lt;span class="nb"&gt;num&lt;/span&gt;.&lt;span class="n"&gt;size&lt;/span&gt;(); &lt;span class="n"&gt;i&lt;/span&gt;++)
        {
            &lt;span class="k"&gt;if&lt;/span&gt;(&lt;span class="nb"&gt;count&lt;/span&gt; == &lt;span class="mi"&gt;0&lt;/span&gt;)
            {
                &lt;span class="n"&gt;candidate&lt;/span&gt; = &lt;span class="nb"&gt;num&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;];
            }

            &lt;span class="k"&gt;if&lt;/span&gt;(&lt;span class="n"&gt;candidate&lt;/span&gt; == &lt;span class="nb"&gt;num&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;])
            {
                &lt;span class="nb"&gt;count&lt;/span&gt;++;
            }

            &lt;span class="k"&gt;else&lt;/span&gt;
            {
                &lt;span class="n"&gt;count--&lt;/span&gt;;
            }
        }
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;candidate&lt;/span&gt;;
    }
};
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Leetcode HighFrequency"></category></entry><entry><title>Leetcode@Pow(x, n)</title><link href="http://www.zhangge208.com/pages/2015/05/26/leetcodepowx-n.html" rel="alternate"></link><updated>2015-05-26T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-05-26:pages/2015/05/26/leetcodepowx-n.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Leetcode@Pow(x, n)&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Implement pow(x, n).&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;分治法&lt;/p&gt;
&lt;p&gt;x^n = x^(n/2) * x^(n/2); x^(n/2) = x^(n/4) * x^(n/4)&lt;/p&gt;
&lt;p&gt;不过有些细节需要注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;n = 0时 return 1&lt;/li&gt;
&lt;li&gt;n &amp;lt; 0时 return 1 / power(x,-n)&lt;/li&gt;
&lt;li&gt;n &amp;gt; 0时，令value = power(x,n/2),需要对n的奇偶性进行讨论。&lt;br /&gt;
  n = 2k + 1时，返回 value * value * x；&lt;br /&gt;
  n = 2k时，返回value * value &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Solution&lt;/span&gt; {
&lt;span class="n"&gt;public:&lt;/span&gt;
    &lt;span class="n"&gt;double&lt;/span&gt; &lt;span class="n"&gt;pow&lt;/span&gt;(&lt;span class="n"&gt;double&lt;/span&gt; &lt;span class="o"&gt;x&lt;/span&gt;, &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;) {
        &lt;span class="k"&gt;if&lt;/span&gt;(&lt;span class="n"&gt;n&lt;/span&gt; &amp;lt; &lt;span class="mi"&gt;0&lt;/span&gt;)
        {
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt; / &lt;span class="n"&gt;power&lt;/span&gt;(&lt;span class="o"&gt;x&lt;/span&gt;, -&lt;span class="n"&gt;n&lt;/span&gt;);
        }
        &lt;span class="k"&gt;else&lt;/span&gt;
        {
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;power&lt;/span&gt;(&lt;span class="o"&gt;x&lt;/span&gt;,&lt;span class="n"&gt;n&lt;/span&gt;);
        }
    }
&lt;span class="n"&gt;private:&lt;/span&gt;
    //&lt;span class="n"&gt;divide&lt;/span&gt; &amp;amp; &lt;span class="n"&gt;conquer&lt;/span&gt;
    &lt;span class="n"&gt;double&lt;/span&gt; &lt;span class="n"&gt;power&lt;/span&gt;(&lt;span class="n"&gt;double&lt;/span&gt; &lt;span class="o"&gt;x&lt;/span&gt;, &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;)
    {
        &lt;span class="k"&gt;if&lt;/span&gt; (&lt;span class="n"&gt;n&lt;/span&gt; == &lt;span class="mi"&gt;0&lt;/span&gt;)
        {
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;;
        }
        &lt;span class="k"&gt;else&lt;/span&gt;
        {
            &lt;span class="n"&gt;double&lt;/span&gt; &lt;span class="nb"&gt;value&lt;/span&gt; = &lt;span class="n"&gt;power&lt;/span&gt;(&lt;span class="o"&gt;x&lt;/span&gt;, &lt;span class="n"&gt;n&lt;/span&gt; / &lt;span class="mi"&gt;2&lt;/span&gt;);
            &lt;span class="k"&gt;if&lt;/span&gt; (&lt;span class="n"&gt;n&lt;/span&gt; % &lt;span class="mi"&gt;2&lt;/span&gt; == &lt;span class="mi"&gt;0&lt;/span&gt;)
            {
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;value&lt;/span&gt; * &lt;span class="nb"&gt;value&lt;/span&gt;;
            }
            &lt;span class="k"&gt;else&lt;/span&gt;
            {
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;value&lt;/span&gt; * &lt;span class="nb"&gt;value&lt;/span&gt; * &lt;span class="o"&gt;x&lt;/span&gt;;
            }
        }
    }
};
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Math"></category></entry><entry><title>Leetcode@Single Number</title><link href="http://www.zhangge208.com/pages/2015/05/26/leetcodesingle-number.html" rel="alternate"></link><updated>2015-05-26T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-05-26:pages/2015/05/26/leetcodesingle-number.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Leetcode@Single Number&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Given an array of integers, every element appears twice except for one. Find that single one.&lt;/p&gt;
&lt;p&gt;Note:
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;异或运算特点（不进位加法）:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a ^ b = c ,a ^ c = b -&amp;gt; b ^ c = a&lt;/li&gt;
&lt;li&gt;a ^ a = 0 （信息抵消）&lt;/li&gt;
&lt;li&gt;a ^ 0 = a&lt;/li&gt;
&lt;li&gt;(a ^ b) ^ c = a ^ (b ^ c)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据 a ^ a = 0,我们可以知道两个相同的数进行异或会相抵消，所以把数组中的所有数异或一遍即可得到答案&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Solution&lt;/span&gt; {
&lt;span class="n"&gt;public:&lt;/span&gt;
    &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;singleNumber&lt;/span&gt;(&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;[], &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;) {
        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="nb"&gt;num&lt;/span&gt; = &lt;span class="mi"&gt;0&lt;/span&gt;;
        &lt;span class="k"&gt;for&lt;/span&gt;(&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; = &lt;span class="mi"&gt;0&lt;/span&gt;; &lt;span class="n"&gt;i&lt;/span&gt; &amp;lt; &lt;span class="n"&gt;n&lt;/span&gt;; &lt;span class="n"&gt;i&lt;/span&gt;++)
        {
            &lt;span class="nb"&gt;num&lt;/span&gt; = &lt;span class="nb"&gt;num&lt;/span&gt; ^ &lt;span class="n"&gt;A&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;];
        }
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;num&lt;/span&gt;;
    }
};
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Leetcode HighFrequency"></category></entry><entry><title>Leetcode@Single Number II</title><link href="http://www.zhangge208.com/pages/2015/05/26/leetcodesingle-number-ii.html" rel="alternate"></link><updated>2015-05-26T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-05-26:pages/2015/05/26/leetcodesingle-number-ii.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Leetcode@Single Number II&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Given an array of integers, every element appears three times except for one. Find that single one.&lt;/p&gt;
&lt;p&gt;Note:
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;构造一个3进制的异或运算（XOR3），使得三个相同的数进行不进位加法（XOR3）后结果为0，与single number1的思路一样。&lt;/p&gt;</summary><category term="Algorithm Leetcode HighFrequency"></category></entry><entry><title>Leetcode@Climbing Stairs</title><link href="http://www.zhangge208.com/pages/2015/05/25/leetcodeclimbing-stairs.html" rel="alternate"></link><updated>2015-05-25T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-05-25:pages/2015/05/25/leetcodeclimbing-stairs.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Leetcode@Climbing Stairs&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;You are climbing a stair case. It takes n steps to reach to the top.&lt;/p&gt;
&lt;p&gt;Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;动态规划的思路，属于sequence DP&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;state: f[i]表示前i个位置，跳到第i个位置共有多少种方案&lt;/li&gt;
&lt;li&gt;function: f[i] = f[i-1] + f[i-2] （跳一步和跳两步）&lt;/li&gt;
&lt;li&gt;intialize: f[0] = 1, f[1] = 1&lt;/li&gt;
&lt;li&gt;answer: f[n]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;小陷阱：动态分配数组的时候要记得数组的大小应为0-n+1&lt;/p&gt;
&lt;p&gt;本题背后的故事实际上是斐波那契数列&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Solution&lt;/span&gt; {
&lt;span class="n"&gt;public:&lt;/span&gt;
    &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;climbStairs&lt;/span&gt;(&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;) {
        &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="s"&gt;&amp;lt;int&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;(&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;);
        &lt;span class="n"&gt;res&lt;/span&gt;[&lt;span class="mi"&gt;0&lt;/span&gt;] = &lt;span class="mi"&gt;1&lt;/span&gt;;
        &lt;span class="n"&gt;res&lt;/span&gt;[&lt;span class="mi"&gt;1&lt;/span&gt;] = &lt;span class="mi"&gt;1&lt;/span&gt;;
        &lt;span class="k"&gt;for&lt;/span&gt;(&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; = &lt;span class="mi"&gt;2&lt;/span&gt;; &lt;span class="n"&gt;i&lt;/span&gt; &amp;lt;= &lt;span class="n"&gt;n&lt;/span&gt;; &lt;span class="n"&gt;i&lt;/span&gt;++)
        {
            &lt;span class="n"&gt;res&lt;/span&gt;[&lt;span class="n"&gt;i&lt;/span&gt;] = &lt;span class="n"&gt;res&lt;/span&gt;[&lt;span class="n"&gt;i-1&lt;/span&gt;] + &lt;span class="n"&gt;res&lt;/span&gt;[&lt;span class="n"&gt;i-2&lt;/span&gt;];
        }
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;[&lt;span class="n"&gt;n&lt;/span&gt;];
    }
};
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;节省空间的写法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;int climbStairs2(int n)  
{  
    vector&amp;lt;int&amp;gt; res(3);  
    res[0] = 1;  
    res[1] = 1;  
    for (int i = 2; i &amp;lt;= n; i++)  
    {  
        res[i%3] = res[(i-1)%3] + res[(i-2)%3];  
    }  
    return res[n%3];  
}
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Leetcode Dynamic Programming"></category></entry><entry><title>Leetcode@House Robber I</title><link href="http://www.zhangge208.com/pages/2015/05/25/leetcodehouse-robber-i.html" rel="alternate"></link><updated>2015-05-25T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-05-25:pages/2015/05/25/leetcodehouse-robber-i.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Leetcode@House Robber I&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.&lt;/p&gt;
&lt;p&gt;Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;属于序列动态规划(Sequence Dp)&lt;/p&gt;
&lt;p&gt;state：f[i]表示到第i个位置时可获得的最大利益&lt;/p&gt;
&lt;p&gt;function：f[i] = max(f[i-1], f[i-2]+nums[i])&lt;/p&gt;
&lt;p&gt;initialize: f[0] = nums[0], f[1] = max(f[0],nums[1])&lt;/p&gt;
&lt;p&gt;answer:f[n-1]&lt;/p&gt;
&lt;p&gt;异常处理，考虑边界情况，nums为空或长度为1的情况&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0){
            return 0;
        }
        int[] f = new int[nums.length];
        for (int i = 0; i &amp;lt; nums.length; i++){
            if (i == 0){
                f[0] = nums[0];
            }
            else if (i == 1){
                f[1] = Math.max(f[0],nums[1]);
            }
            else{
                f[i] = Math.max(f[i - 1],f[i - 2]+nums[i]);
            }
        }
        return f[nums.length - 1];
    }
}
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Leetcode Dynamic Programming"></category></entry><entry><title>Leetcode@House Robber II</title><link href="http://www.zhangge208.com/pages/2015/05/25/leetcodehouse-robber-ii.html" rel="alternate"></link><updated>2015-05-25T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-05-25:pages/2015/05/25/leetcodehouse-robber-ii.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;Leetcode@House Robber II&lt;/h1&gt;
&lt;h2&gt;题目&lt;/h2&gt;
&lt;p&gt;Note: This is an extension of House Robber.&lt;/p&gt;
&lt;p&gt;After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street.&lt;/p&gt;
&lt;p&gt;Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;题目变化导致的特殊判断条件为是否抢劫第一件房屋。如果是，则不能抢最后一件房屋。否则，可以抢最后一间房屋。&lt;/p&gt;
&lt;p&gt;以此为依据，将环形DP问题转化为两次序列DP问题&lt;/p&gt;
&lt;p&gt;异常处理，考虑边界情况，nums为空或长度为1的情况&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;public class Solution {
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0){
            return 0;
        }
        if (nums.length == 1){
            return nums[0];
        }
        int prev = 0;
        int cur = 0;
        for (int i = 1; i &amp;lt; nums.length; i++){
            int temp = cur;
            cur = Math.max(cur, prev + nums[i]);
            prev = temp;
        }
        int missing_first = cur;

        prev = 0;
        cur = 0;
        for (int i = 0; i &amp;lt; nums.length - 1; i++){
            int temp = cur;
            cur = Math.max(cur, prev + nums[i]);
            prev = temp;
        }
        int missing_last = cur;

        return Math.max(missing_first,missing_last);
    }
}
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Leetcode Dynamic Programming"></category></entry><entry><title>Leetcode@Linked List Cycle</title><link href="http://www.zhangge208.com/pages/2015/01/19/leetcodelinked-list-cycle.html" rel="alternate"></link><updated>2015-01-19T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-01-19:pages/2015/01/19/leetcodelinked-list-cycle.html</id><summary type="html">&lt;h1&gt;题目&lt;/h1&gt;
&lt;p&gt;Given a linked list, determine if it has a cycle in it.&lt;/p&gt;
&lt;p&gt;Follow up:
Can you solve it without using extra space?&lt;/p&gt;
&lt;h1&gt;解题思路&lt;/h1&gt;
&lt;p&gt;判断一个链表是否存在环。所谓有环，是指链表的尾节点指向了链表的某一个中间节点。不使用额外空间是要求算法的空间复杂度为O(1)。
   一般标准的思路是使用快慢两个指针，fast指针每次走两步，slow指针每次走一步。fast和slow指针在初始时均指向头结点。由于fast指针的速度是slow指针的两倍，若链表存在环路，在进入环路后，两个指针一定会相遇，即某一时刻，若slow == fast ，表明链表存在环路。如无环，则有fast或fast.next  == None。这个思路下的算法复杂度为O(n)。
   需要注意几个特殊点：1.非空链表才有存在环的可能，空链表是无环的  2.若链表只有一个节点，则属于环。&lt;/p&gt;
&lt;h1&gt;代码&lt;/h1&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * Definition for singly-linked list.&lt;/span&gt;
&lt;span class="cm"&gt; * struct ListNode {&lt;/span&gt;
&lt;span class="cm"&gt; *     int val;&lt;/span&gt;
&lt;span class="cm"&gt; *     ListNode *next;&lt;/span&gt;
&lt;span class="cm"&gt; *     ListNode(int x) : val(x), next(NULL) {}&lt;/span&gt;
&lt;span class="cm"&gt; * };&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
class&lt;span class="w"&gt; &lt;/span&gt;Solution&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="nl"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;bool&lt;span class="w"&gt; &lt;/span&gt;hasCycle&lt;span class="o"&gt;(&lt;/span&gt;ListNode&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;head&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;ListNode&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;p&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;NULL&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;ListNode&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;q&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;NULL&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;p&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;q&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;head&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;while&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;p&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;p&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;next&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;p&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;p&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;next&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;next&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;q&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;q&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;next&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="kr"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;p&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;q&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;true&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kr"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;false&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="err"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm LinkedList"></category></entry><entry><title>Leetcode@Search in Rotated Sorted Array II</title><link href="http://www.zhangge208.com/pages/2015/01/19/leetcodesearch-in-rotated-sorted-array-ii.html" rel="alternate"></link><updated>2015-01-19T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-01-19:pages/2015/01/19/leetcodesearch-in-rotated-sorted-array-ii.html</id><summary type="html">&lt;hr /&gt;
&lt;h1&gt;题目&lt;/h1&gt;
&lt;p&gt;Follow up for "Search in Rotated Sorted Array":
What if duplicates are allowed?&lt;/p&gt;
&lt;p&gt;Would this affect the run-time complexity? How and why?&lt;/p&gt;
&lt;p&gt;Write a function to determine if a given target is in the array.&lt;/p&gt;
&lt;h1&gt;解题思路&lt;/h1&gt;
&lt;p&gt;在上一题”Search in Rotated Array“中假设数组不会出现重复元素。但如果允许出现重复的元素，那么对中间和边缘相等的情况需要进行特殊的处理。原来的题目通过中间与边缘元素的比较来判断哪一半为有序的，但现在出现了重复，这导致若边缘与中间相等，将无法判断有序部分的情况，例如,原来为[1,2,3,4,4,4,4,4,4],翻转后变为[4,4,4,4,4,1,2,3,4],这样一来，无论中心边缘都相等，在寻找1或2时，根本无法判断应跳向哪一步。为解决这一问题，只有将边缘移动一步，直到边缘和中间不再相等，或者中间与边缘已经重合。在最坏情况时，即序列为同一元素时，时间复杂度会退化至O(n)。&lt;/p&gt;
&lt;h1&gt;代码&lt;/h1&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Solution&lt;/span&gt;{
&lt;span class="n"&gt;public:&lt;/span&gt;
    &lt;span class="nb"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;search&lt;/span&gt;(&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;[], &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;, &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;target&lt;/span&gt;) {
        &lt;span class="k"&gt;if&lt;/span&gt;(&lt;span class="n"&gt;NULL&lt;/span&gt; == &lt;span class="n"&gt;A&lt;/span&gt; || &lt;span class="mi"&gt;0&lt;/span&gt; == &lt;span class="n"&gt;n&lt;/span&gt;)  
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;false&lt;/span&gt;;  
        &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt; = &lt;span class="mi"&gt;0&lt;/span&gt;, &lt;span class="n"&gt;right&lt;/span&gt; = &lt;span class="n"&gt;n-1&lt;/span&gt;, &lt;span class="n"&gt;mid&lt;/span&gt; = &lt;span class="mi"&gt;0&lt;/span&gt;;  
        &lt;span class="k"&gt;while&lt;/span&gt;(&lt;span class="n"&gt;left&lt;/span&gt; &amp;lt;= &lt;span class="n"&gt;right&lt;/span&gt;)  
        {  
            &lt;span class="n"&gt;mid&lt;/span&gt; = &lt;span class="n"&gt;left&lt;/span&gt;+(&lt;span class="n"&gt;right-left&lt;/span&gt;)/&lt;span class="mi"&gt;2&lt;/span&gt;;  
            &lt;span class="k"&gt;if&lt;/span&gt;(&lt;span class="n"&gt;A&lt;/span&gt;[&lt;span class="n"&gt;mid&lt;/span&gt;] == &lt;span class="n"&gt;target&lt;/span&gt;)  
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;;
            &lt;span class="k"&gt;if&lt;/span&gt;(&lt;span class="n"&gt;A&lt;/span&gt;[&lt;span class="n"&gt;mid&lt;/span&gt;] &amp;gt; &lt;span class="n"&gt;A&lt;/span&gt;[&lt;span class="n"&gt;left&lt;/span&gt;])
            {
                &lt;span class="k"&gt;if&lt;/span&gt;(&lt;span class="n"&gt;target&lt;/span&gt; &amp;lt; &lt;span class="n"&gt;A&lt;/span&gt;[&lt;span class="n"&gt;mid&lt;/span&gt;] &amp;amp;&amp;amp; &lt;span class="n"&gt;target&lt;/span&gt; &amp;gt;=&lt;span class="n"&gt;A&lt;/span&gt;[&lt;span class="n"&gt;left&lt;/span&gt;])
                {
                    &lt;span class="n"&gt;right&lt;/span&gt; = &lt;span class="n"&gt;mid&lt;/span&gt; - &lt;span class="mi"&gt;1&lt;/span&gt;;
                }
                &lt;span class="k"&gt;else&lt;/span&gt;
                {
                    &lt;span class="n"&gt;left&lt;/span&gt; = &lt;span class="n"&gt;mid&lt;/span&gt; + &lt;span class="mi"&gt;1&lt;/span&gt;;
                }
            }
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; (&lt;span class="n"&gt;A&lt;/span&gt;[&lt;span class="n"&gt;mid&lt;/span&gt;]&amp;lt; &lt;span class="n"&gt;A&lt;/span&gt;[&lt;span class="n"&gt;left&lt;/span&gt;])
            {
                &lt;span class="k"&gt;if&lt;/span&gt;(&lt;span class="n"&gt;target&lt;/span&gt; &amp;gt;&lt;span class="n"&gt;A&lt;/span&gt;[&lt;span class="n"&gt;mid&lt;/span&gt;] &amp;amp;&amp;amp; &lt;span class="n"&gt;A&lt;/span&gt;[&lt;span class="n"&gt;right&lt;/span&gt;] &amp;gt;= &lt;span class="n"&gt;target&lt;/span&gt; )
                {
                    &lt;span class="n"&gt;left&lt;/span&gt; = &lt;span class="n"&gt;mid&lt;/span&gt; +&lt;span class="mi"&gt;1&lt;/span&gt;;
                }
                &lt;span class="k"&gt;else&lt;/span&gt;
                {
                    &lt;span class="n"&gt;right&lt;/span&gt; = &lt;span class="n"&gt;mid&lt;/span&gt; -&lt;span class="mi"&gt;1&lt;/span&gt;;
                }
            }
            &lt;span class="k"&gt;else&lt;/span&gt;
            {
                &lt;span class="n"&gt;left&lt;/span&gt; = &lt;span class="n"&gt;left&lt;/span&gt; + &lt;span class="mi"&gt;1&lt;/span&gt;;
            }
        }
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;false&lt;/span&gt;;
    }

};
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Algorithm Binary Search"></category></entry><entry><title>来算法吧~</title><link href="http://www.zhangge208.com/pages/2015/01/04/lai-suan-fa-ba.html" rel="alternate"></link><updated>2015-01-04T00:00:00+08:00</updated><author><name>zhangge208</name></author><id>tag:www.zhangge208.com,2015-01-04:pages/2015/01/04/lai-suan-fa-ba.html</id><summary type="html">&lt;p&gt;2015的第一季度要开始系统地学习算法，虽然只有不到一个月的假期！！！唉 ，不过把之前零零散散看的复习一下，然后还是有不少时间可是学到好多没看过的。不过呢，先慢慢来吧！
   我是想每天坚持写，坚持看，对某一个算法先理解基本的思想，算法运行的实际过程，给出代码实现，其实语言神马的，根本就不重要。。。然后会慢慢地进行算法分析，只是数学这东西，唉，不说了，说多了都是泪。最后给一些能运用到这种算法思想的小例子。说白了，也就是把leetcode和挑战程序设计竞赛上面的题目做会。
   就扯这么多吧！希望2015年，能够有突破性的进展！&lt;/p&gt;</summary><category term="Algorithm"></category></entry></feed>